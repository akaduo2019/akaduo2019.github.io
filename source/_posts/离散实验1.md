---
title: 求主析取范式和主合取范式
date: 2020-10-21 20：30
tags:
- experiment
categories:
- python
---
编程实现用真值表法求取含n个变元的合式公式所对应的主析取范式和主合取范式。
要求：
能够列出合式公式的真值表并给出相应主析取和主合取范式。
<!--more-->

```py
#对用户输入值进行处理
def pretreatment():
    #Ⅰ将用户输入值分割为一个个字符并以列表形式储存；
    in_put = input("或运算为 |  , 与运算为 &   ,单条件为 ->  ,双条件我 <=> ,非运算为 ! ,变元采用大写\n请输入表达式，并以回车结束\n")
    for value in in_put:
        infix.append(value)
    #Ⅱ将双条件 <= > 视为 < ；将条件->视为 -
    while '=' in infix:
        infix.remove('=')
    while '>' in infix:
        infix.remove('>')
    #Ⅲ 将合式中的变元储存到列表alpha中
    for value in infix:
        if value <= 'Z' and value >= 'A':
            if value not in alpha:
                alpha.append(value)
#中缀表达式转化为后缀表达式的函数
def infix_to_suffix(_infix):
    # 清空stack
    stack.clear()
    # 从左向右遍历
    for value in _infix:
        # 当遇到运算数时直接输出
        if value <= 'Z' and value >= 'A':
            suffix.append(value)
        # 遇到左括号为最高优先级，直接压入堆栈，注意入栈后左括号优先级将为最低，确保其他符号正常入栈
        elif value == '(':
            stack.append(value)
        # 遇到右括号，不断弹出栈顶运算符并输出，直到遇到左括号，左括号弹出但不输出
        elif value == ')':
            while stack[-1] != '(':
                suffix.append(stack.pop())
            # 弹出左括号
            stack.pop()
        # 若该运算符与栈顶元素比较，其优先级低于等于栈顶元素，应将栈顶运算符弹出并输出，然后与新的栈顶元素符比较；
        # 若栈为空或与栈顶元素比较，优先级高于栈顶元素，则应压入堆栈；
        elif value == '|' or value =='&' or value =='-' or value =='<':
            if stack:
                if stack[-1]=='(':
                    stack.append(value)
                else:
                    suffix.append(stack.pop())
                    if stack:
                        while stack[-1] != '(':
                            suffix.append(stack.pop())
                            if not stack:
                                break
                    stack.append(value)


            else:
                stack.append(value)
        # 遇到运算符：非
        elif value == '!':
            #栈不为空
            if stack:
                #如果栈顶元素也为 非，那么此时运算符优先级低于或等于栈顶元素优先级，应将栈顶运算符弹出并输出，然后比较新的栈顶运算符
                if stack[-1] == '!':
                    suffix.append(stack.pop())
                    # 当栈不为空且栈顶元素仍为 非 ，则继续比较
                    while stack and stack[-1] == '!':
                        suffix.append(stack.pop())
                    #弹出到栈顶元素不为非或者栈为空时，将该运算符 非 压入堆栈
                    stack.append(value)
                else:
                    stack.append(value)
            #栈为空，直接压入堆栈
            else:
                stack.append(value)
    #最后按顺序弹出栈内值并输出
    while stack:
        suffix.append(stack.pop())
#后缀表达式对应的真值的计算
def calculate():
    stack.clear()
    #从左向右遍历
    for value in suffix:
        #遇到运算数，将运算数对应的真值压入堆栈
        if value >= 'A' and value <= 'Z':
             stack.append(truth_table[value])
        #遇到运算符&
        elif value == '&':
            number_1 = stack.pop()
            number_2 = stack.pop()
            if number_1 == 1 and number_2 == 1:
                stack.append(1)
            else:
                stack.append(0)
        #遇到运算符|
        elif value == '|':
            number_1 = stack.pop()
            number_2 = stack.pop()
            if number_1 == 0 and number_2 == 0:
                stack.append(0)
            else:
                stack.append(1)
        #遇到运算符->
        elif value == '-':
            number_1 = stack.pop()
            number_2 = stack.pop()
            if number_1 == 0 and number_2 == 1:
                stack.append(0)
            else:
                stack.append(1)
        #遇到运算符<=>
        elif value == '<':
            number_1 = stack.pop()
            number_2 = stack.pop()
            if number_1 == number_2 :
                stack.append(1)
            else:
                stack.append(0)
        #遇到运算符！
        elif value == '!':
            number = stack.pop()
            if number == 1:
                stack.append(0)
            elif number == 0:
                stack.append(1)
    #返回栈顶元素值，即结果
    return stack[-1]
#递归方法实现真值表的全排列
def recursive(num):
    if num == len(alpha):
        ans = calculate()
        for i in range(0,len(alpha)):
            if truth_table[alpha[i]] == 1:
                print("T\t",end='')
            else:
                print("F\t",end='')
        if ans == 1:
            print("T\n")
            for i in range(0,len(alpha)):
                true.append(truth_table[alpha[i]])
        else:
            print("F\n")
            for i in range(0,len(alpha)):
                false.append(truth_table[alpha[i]])
    else:
        truth_table[alpha[num]] = 1
        recursive(num+1)
        truth_table[alpha[num]] = 0
        recursive(num+1)
#求取主析取范式
def turn_to_pdnf():
    if true:
        print("主析取范式为：")
        for i in range(0,len(true),len(alpha)):
            j = i % len(alpha)
            print('(', end='')
            for k in range(0,len(alpha)):
                print(transform_1(true[i+k])+alpha[j+k],end='')
                if k<len(alpha)-1:
                    print('∧',end='')
            print(')',end='')
            if i < len(true)-len(alpha) and len(true) != len(alpha):
                print("∨",end='')
        print("")
#求取主合取范式
def turn_to_pcnf():
    if false:
        print("主合取范式为：")
        for i in range(0, len(false), len(alpha)):
            j = i % len(alpha)
            print('(', end='')
            for k in range(0, len(alpha)):
                print(transform_2(false[i + k]) + alpha[j + k], end='')
                if k < len(alpha) - 1:
                    print('∨', end='')
            print(')', end='')
            if i < len(false)-len(alpha) and len(false) != len(alpha):
                print('∧', end='')
        print("")
#析取中非的符号转换
def transform_1(value):
    if value == 0:
        return '¬'
    else:
        return ""
#合取中非的符号转换
def transform_2(value):
    if value == 1:
        return  '¬'
    else:
        return  ""
# 储存中缀表达式
infix = []
# 储存变元
alpha = []
# 存放转化后的后缀表达式
suffix = []
# 用作中间运算的堆栈
stack = []
# 映射:字典truth_table:key为alpha中的元素，value为0或1
truth_table = {}
# 存放合式为真的情况，用于主析取范式
true = []
# 存放合式为假的情况，用于主合取范式
false = []

pretreatment()
infix_to_suffix(infix)
for i in range(0,len(alpha)):
    print(alpha[i]+"\t",end='')
print("表达式真值")
recursive(0)
turn_to_pdnf()
turn_to_pcnf()
```
