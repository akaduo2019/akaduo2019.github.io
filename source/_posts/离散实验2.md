---
title: 集合上二元关系性质的判断
date: 2020-10-29 22：54
tags:
- experiment
categories:
- python
---
编程实现集合上二元关系性质的判断，并求自反闭包，对称闭包和传递闭包(warshall算法)
<!--more-->

```py
# 存放输入的集合A
A=[]
# S=A×A
S=[]
# 存放输入的关系R
R=[]
# 存放R的关系矩阵
matrix={}
# 存放R的自反闭包
r_R=[]
# 存放R的对称闭包
s_R=[]
# 存放R的传递闭包
t_R=[]
# 存放A的恒等关系
I_A=[]
# 存放R的逆关系
R_c=[]


# 输入函数
def in_put():
    input_A=input("注:请用英文逗号,大括号,大于号和小于号\n输入集合A,以回车结束\n")
    input_R=input("输入集合R,以回车结束\n")
    for value in input_A:
        A.append(value)
    for value in input_R:
        R.append(value)
    # 移除A中的, { }
    while ',' in A:
        A.remove(',')
    while '{' in A:
        A.remove('{')
    while '}' in A:
        A.remove('}')
    # 移除R中的<,> { }
    while '<' in R:
        R.remove('<')
    while '>' in R:
        R.remove('>')
    while ',' in R:
        R.remove(',')
    while '{' in R:
        R.remove('{')
    while '}' in R:
        R.remove('}')

# 根据S=A×A，求S集合
def turn_to_S():
    for value_1 in range(0,len(A)):
        for value_2 in range(0,len(A)):
            S.append(A[value_1])
            S.append(A[value_2])

# 根据R和S求关系矩阵
def turn_to_matrix():
    for i in range(0,len(R),2):
        for j in range(0,len(S),2):
            if R[i] == S[j] and R[i+1] == S[j+1]:
                matrix[round(j/2)]=1
    # 补上0，补全矩阵
    for i in range(0,len(A)):
        for j in range(0,len(A)):
            if round(len(A)*i+j) not in matrix.keys():
                matrix[round(len(A)*i+j)]=0

# 判断自反性
def judge_reflexivity():
    # 若flag为True则表示关系矩阵对角线元素全为1，flag预设值为Ture
    flag=True
    for i in range(0,len(A)):
        if matrix[len(A)*i+i] != 1:
            flag=False
            break
    if flag:
        print("自反")

# 判断对称性
def judge_symmetry():
    # 若flag为True则表示R对称，预设值为True
    flag=True
    for i in range(0,len(A)):
        # for…else…的运行逻辑是当for循环正常执行结束就会运行其else语句，如果中途break的话，就不会执行else中的内容
        for j in range(0,len(A)):
            # 如果不是主对角线元素
            if len(A)*i+j != len(A)*i+i:
                # 关于主对角线对称的元素值不相等则，flag=False
                if matrix[len(A)*i+j] != matrix[len(A)*j+i]:
                    flag=False
                    break
        else:
            continue
        break
    if flag:
        print("对称")

# 判断反自反性
def judge_ud_reflexivity():
    # 若flag为True则表示关系矩阵对角线元素全为0，flag预设值为Ture
    flag = True
    for i in range(0, len(A)):
        if matrix[len(A) * i + i] != 0:
            flag = False
            break
    if flag:
        print("反自反")

# 判断反对称性
def judge_ud_symmetry():
    # 若flag为True则表示R反对称，预设值为True
    flag = True
    for i in range(0, len(A)):
        for j in range(0, len(A)):
            # 如果不是主对角线元素
            if len(A) * i + j != len(A) * i + i:
                # 关于主对角线对称的元素同时为1，flag=False
                if matrix[len(A) * i + j] == 1 and  matrix[len(A) * j + i] == 1:
                    flag = False
                    break
        else:
            continue
        break
    if flag:
        print("反对称")

# 判断传递性
def judge_transitivity():
    # 若flag为True则表示R具有传递性，预设值为True
    flag=True
    for i in range(0,len(R),2):
        for j in range(i+2,len(R),2):
            if R[i+1] == R[j]:
                # 设任意x∈R，y∈R，z∈R，若xRy，yRz可推出xRz，则R具有传递性
                # 若pos=False则代表:当xRy,yRz时, <x,z>不属于R，反之，代表其属于R
                pos=False
                for k in range(0, len(R), 2):
                        if  R[i] == R[k] and R[j+1] == R[k+1]:
                            pos=True
                            break
                if not pos:
                    flag=False
                    break
        else:
            continue
        break
    if flag:
       print("传递")

# 求自反闭包,并输出
def turn_to_reflexive_closure():
    # 求A的恒等关系I_A
    for i in range(0,len(A)):
        I_A.append(A[i])
        I_A.append(A[i])
    # 先将R导入自反闭包r_R
    for i in range(0,len(R)):
        r_R.append(R[i])
    # r(R)=R∪IA
    for i in range(0, len(I_A), 2):
        # flag=True代表A的恒等关系中的该元素不在二元关系R中，应导入对称闭包，flag预设值为True
        flag = True
        for j in range(0, len(R), 2):
            if R[j] == I_A[i] and R[j + 1] == I_A[i + 1]:
                flag = False
                break
        if flag:
            r_R.append(I_A[i])
            r_R.append(I_A[i+1])

    # 自反闭包输出部分
    print("r(R) = ",end='')
    print('{',end='')
    for i in range(0,len(r_R),2):
        if i == len(r_R)-2:
            print('<'+r_R[i]+','+r_R[i+1]+'>',end='')
        else:
            print('<'+r_R[i]+','+r_R[i+1]+'>'+',',end='')
    print('}')

# 求对称闭包,并输出
def turn_to_Symmetric_closure():
    # 求R的逆关系R_c
    for i in range(0,len(R),2):
        R_c.append(R[i+1])
        R_c.append(R[i])
    # 先将R导入对称闭包s_R
    for i in range(0,len(R)):
        s_R.append(R[i])
    # s(R)=R∪R^c
    for i in range(0, len(R_c), 2):
        # flag代表R_c中该元素不在二元关系R中，应导入对称闭包，flag预设值为True
        flag = True
        for j in range(0, len(R), 2):
            if R[j] == R_c[i] and R[j + 1] == R_c[i + 1]:
                flag = False
                break
        if flag:
            s_R.append(R_c[i])
            s_R.append(R_c[i+1])

    #对称闭包输出部分
    print("s(R) = ", end='')
    print('{', end='')
    for i in range(0, len(s_R), 2):
        if i == len(s_R) - 2:
            print('<' + s_R[i] + ',' + s_R[i + 1] + '>', end='')
        else:
            print('<' + s_R[i] + ',' + s_R[i + 1] + '>' + ',', end='')
    print('}')

# 求传递闭包 warshall算法
def turn_to_transitive_closure():
    #置新矩阵B：=M_R
    B={}
    B=matrix
    #i为实际行数
    i=0
    #j为列数
    for j in range(0,len(A)):
        # k为处理行数
        for k in range(0,len(A)):
            #len(A)*k+j 代表一列上的一个元素   遍历完k，即代表一列
            #如果某列上的一个元素等于1，则将该元素处于的行(即处理行)与i的值代表的行(即实际行)进行逻辑加，将结果存于处理行
            if B[len(A)*k+j] == 1:
                for l in range(0,len(A)):
                    if B[len(A)*i+l]==0 and B[len(A)*k+l]==0:
                        B[len(A)*k+l]=0
                    else:
                        B[len(A)*k+l]=1
        # 处理完一列将i自增1
        i = i + 1
        if i == len(A):
            break

    #传递闭包输出部分
    for i in range(0,len(B)):
        #B[i]代表关系矩阵中的某一个元素
        if B[i] == 1:
            #row代表该元素处于哪一行，col代表该元素处于哪一列
            row = i // len(A)
            col = i %  len(A)
            #将该关系矩阵中的这个元素所代表的序偶导入到传递闭包中
            t_R.append(S[(row*len(A)+col)*2])
            t_R.append(S[(row*len(A)+col)*2+1])
    print("t(R) = ", end='')
    print('{', end='')
    for i in range(0, len(t_R), 2):
        if i == len(t_R) - 2:
            print('<' + t_R[i] + ',' + t_R[i+1] + '>', end='')
        else:
            print('<' + t_R[i] + ',' + t_R[i+1] + '>' + ',', end='')
    print('}')

# 输入A和R
in_put()
# S=A×A
turn_to_S()
# 求出R的关系矩阵matrix
print("在A集合上二元关系R的性质:")
turn_to_matrix()
# 判断自反性
judge_reflexivity()
# 判断对称性
judge_symmetry()
# 判断反自反性
judge_ud_reflexivity()
# 判断反对称性
judge_ud_symmetry()
# 判断传递性
judge_transitivity()
# 求自反闭包
turn_to_reflexive_closure()
# 求对称闭包
turn_to_Symmetric_closure()
# 求传递闭包
turn_to_transitive_closure()

```
