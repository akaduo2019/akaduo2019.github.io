---
title: 偏序关系中盖住关系的求取及格论中有补格的判定
date: 2020-10-29 22：54
tags:
- experiment
categories:
- python
---
编程实现整除关系这一偏序关系上所有盖住关系的求取，并判断其对应的偏序集是否为有补格

```py
# 存放集合上的所有可能元素
A = []
# 存放整除关系
R = []
# 存放最终的盖住关系
COV = []
# 存放哈斯图的所有元素
HASS = []

# 将该整除关系中的所有元素提取出来
def get_element():
    for i in range(1, int(message)+1):
        if int(message) % i == 0:
            A.append(str(i))
    print(message + "的所有因子的集合:")
    print(A)
# 生成序偶，存放于整除关系中
def create_order_pair():
    for i in A:
        for j in A:
            if int(j) % int(i) == 0 :
                R.append(i)
                R.append(j)
    print("偏序关系≤ = ", end='')
    print(R)

# 求取盖住关系
def get_COVA():
    # 存放恒等关系IA
    IA = []
    # 存放传递关系T
    T = []
    # 输入部分，调用预处理函数
    buffer_A = A
    buffer_R = R
    # 删去偏序关系中的恒等关系IA
    # 确立A中的恒等关系IA
    for element in buffer_A:
        IA.append(element)
        IA.append(element)
    # 遍历偏序关系R中的所有元素，若有恒等关系则删去
    # 外层循环为IA，内层循环为R
    for i in range(0, len(IA)):
        for j in range(0, len(buffer_R), 2):
            if IA[i] == buffer_R[j] and IA[i] == buffer_R[j + 1]:
                del buffer_R[j]
                # 在删去元素处填入一个空格，防止列表下标发生改变
                buffer_R.insert(j, ' ')
                del R[j + 1]
                buffer_R.insert(j + 1, ' ')
    # 在偏序关系中的恒等关系删除完毕后，将所有空格删去
    while ' ' in buffer_R:
        buffer_R.remove(' ')

    # 删除偏序关系关系中的传递关系(此时的偏序关系中已经删去了恒等关系)
    # 得到R中传递关系T
    for i in range(0, len(buffer_R), 2):
        for j in range(0, len(buffer_R), 2):
            if i != j:
                if buffer_R[i + 1] == buffer_R[j]:
                    # 判断序偶是否重复存入传递关系T中
                    if not T:
                        flag = True
                        for k in range(0, len(T), 2):
                            if buffer_R[i] == T[k] and buffer_R[j + 1] == T[k + 1]:
                                flag = False
                                break
                        if flag:
                            T.append(buffer_R[i])
                            T.append(buffer_R[j + 1])
                    else:
                        T.append(buffer_R[i])
                        T.append(buffer_R[j + 1])
    # 删去R中的传递关系T
    # 外层循环为T，内层循环为R
    for i in range(0, len(T), 2):
        for j in range(0, len(buffer_R), 2):
            if T[i] == buffer_R[j] and T[i + 1] == buffer_R[j + 1]:
                del buffer_R[j]
                buffer_R.insert(j, ' ')
                del buffer_R[j + 1]
                buffer_R.insert(j + 1, ' ')
    # 删去多余空格
    while ' ' in buffer_R:
        buffer_R.remove(' ')
    # 盖住关系(没有符号，只有元素)
    COV.append(buffer_R)
    # 得到最终的盖住关系COV
    buffer = ''
    for i in range(0, len(buffer_R), 2):
        if i == 0:
            buffer = buffer + '{<' + buffer_R[i] + ',' + buffer_R[i + 1] + '>,'
        elif i == len(buffer_R) - 2:
            buffer = buffer + '<' + buffer_R[i] + ',' + buffer_R[i + 1] + '>}'
        else:
            buffer = buffer + '<' + buffer_R[i] + ',' + buffer_R[i + 1] + '>,'
    # 得到处理的盖住关系
    COV.append(buffer)
    print("盖住关系COVA = ", end='')
    print(COV[1])


# 由于整除关系对应的偏序集都为格，所以只需要判定有补格。其中全下界一定为1，而全上界对应的是输入的正整数。
# 如果每个元素都能找到另一个元素，使他们的最小公倍数为输入的正整数，即全上界；使他们的最大公因数为1，则判定为有补格

# 求最大公因数的函数，返回最大公因数
def hcf(x, y):
    # 获取最小值
    if x > y:
        smaller = y
    else:
        smaller = x

    for i in range(1, smaller + 1):
        if ((x % i == 0) and (y % i == 0)):
            hcf = i

    return hcf


# 求最小公倍数的函数，返回最小公倍数
def lcm(x, y):
    #  获取最大的数
    if x > y:
        greater = x
    else:
        greater = y

    while (True):
        if ((greater % x == 0) and (greater % y == 0)):
            lcm = greater
            break
        greater += 1

    return lcm


# 判断有补格
def judge_youbuge():
    flags = []
    for i in range(0, len(A)):
        flag = False
        flags.append(flag)
        for j in range(0, len(A)):
            if A[i] != A[j]:
                if lcm(int(A[i]), int(A[j])) == int(message) and hcf(int(A[i]), int(A[j])) == 1:
                    flags[i] = True
                    break
    all_flag = True
    for i in range(0, len(A)):
        if flags[i] == False:
            all_flag = False
            break
    if all_flag:
        print("该整除关系对应的偏序集为有补格")
    else:
        print("该整除关系对应的偏序集非有补格")


if __name__ == '__main__':
    message = input("请输入一个正整数，验证其上的整除关系及其是否为有补格\n")
    get_element()
    create_order_pair()
    get_COVA()
    judge_youbuge()
```
