---
title: 操作系统实验3 内存管理
date: 2021-11-23 14：30
tags:
- experiment
categories:
- c++
---

# 实验要求

1、随机生成一个进程访问的逻辑页号列表，要求不少于100个页号，把这些页号存入文件page.txt。

2、编程分别实现FIFO、LRU和CLOCK算法，每次调用算法前要求用户输入页框数量，每种算法最后都需要给出页面的置换顺序以及缺页中断次数。

 3、不断地改变页框数，完成这张曲线图，并且做出简短的小结，用于分析页框数对缺页率的影响。

程序最好能集成成一个，首先能分行输出显示随机生成的100个页号；然后让用户选择页框数，以页框数作为参数调用三个页面替换策略，记录、输出、比较它们的缺页中断次数、缺页中断率。结果不一定以曲线图形式显示，但要能保存在文件中并能在屏幕上以字符方式输出。

# 实现代码

```c++
#include <stdio.h> 
#include <stdlib.h>
#include <time.h>
#include <math.h>

int main(){
    FILE *fp;
    FILE *fp1;
    FILE *fp2;
    int request[100];
    char input[100];
    int i,j,s=0;
    int page_table_count = 0;//记录文件中的页表数
    int page_frame_count = 0;//页框数
    int page_missing_count;//缺页数
    float page_fault_rate;//缺页率
    srand(time(NULL));//随机种子
    
    fp = fopen('page.txt','w');
    if (fp == NULL)
        return -1;
    fp2 = fopen('result.txt','a++');
    //生成100个20以内的随机数
    for (i=0;i<100;i++){
        j = rand % 20;
        fprintf(fp,"%d",j);
        fprintf(fp2,"%d",j);
    }
    fclose(fp);
    //fp1只读，fp只写
    fp1 = fopen('page.txt','r');
    if (fp1 == NULL)
        return -1;
    //读取page.txt中的请求队列
    while(fscanf(fp1,'%d',&request[page_table_count]) != EOF){
        page_table_count++;
        printf('\n'); 
        printf('================================================================================\n')
        print("请求队列长度(页表数):%d\n",page_table_count)；
        for (i=0;i<page_table_count;i++){
            print('%d',request[i]);//具体展示请求队列页表号顺序
        }
        print('\n');
         printf('================================================================================\n')
        print("请输入分配给进程的页框数:");
        scanf("%d",&page_frame_count);
        printf('\n');
        printf("页框数:%d\n",page_frame_count);
        printf('================================================================================\n')
        //保存请求队列长度(页表数)和页框数到result.txt
        fprintf(fp2,"页表数:%d\n",page_table_count);
        fprintf(fp2,"页框数:%d\n",page_frame_count);
        
        page_missing_count=FIFO(request,page_table_count,page_frame_count);
        printf("FIFOFIFO:\n缺页数:%d\n",page_missing_count);
        fprintf(fp2, "FIFO: %d \n", page_missing_count);
        page_fault_rate = (float)page_missing_count/page_table_count;
        printf("缺页率: %.2f\n", page_fault_rate);
        fprintf(fp2, "缺页率: %.2f\n", page_fault_rate);
        printf("==================================================================================\n");

        page_missing_count =LRU(request,page_table_count,page_frame_count);
        printf("LRU:\n缺页数:%d\n",page_missing_count);
        fprintf(fp2, "LRU: %d \n", page_missing_count);
        page_fault_rate = (float)page_missing_count/page_table_count;
        printf("缺页率: %.2f\n", page_fault_rate);
        fprintf(fp2, "缺页率: %.2f\n", page_fault_rate);
        printf("==================================================================================\n");

        page_missing_count =CLO(request,page_table_count,page_frame_count);
        printf("CLOCK:\n缺页数:%d\n",page_missing_count);
        fprintf(fp2, "CLOCK: %d \n", page_missing_count);
        rate = (float)count/M;
        page_fault_rate = (float)page_missing_count/page_table_count;
        printf("缺页率: %.2f\n", page_fault_rate);
        fprintf(fp2, "缺页率: %.2f\n", page_fault_rate);
        printf("===================================================================================\n");
        fprintf(fp2, "===================================================================================\n");

         //关闭文件指针
        fclose(fp1);
        fclose(fp2);
        return 0;	       
}
"""给数组赋值"""
void setarray(int arr[], int num, int val) 
{  
	int i;
	
	for (i = 0; i < num; i++)   
		arr[i] = val; 
}
"""声明一个二维数组用来存储内存中页面变化情况"""
void initarr(int **arr, int rnum, int cnum)
{
    int r, c;
    for(r = 0; r < rnum; r++)
    {
        for(c = 0; c < cnum; c++)
            arr[r][c] = -1;
    }
}
"""查找内存 mem 中是否存在页面 page"""
int findexist(int mem[], int mnum, int page) 
{  
	int i;
	
	for (i = 0; i < mnum; i++){
		if (mem[i] == page)
			return i;  
	}
	
	return -1; 
}

"""查找内存 mem 中是否存空的位置"""
int findempty(int mem[], int mnum) 
{  
	int i; 
	
	for (i = 0; i < mnum; i++){   
		if (mem[i] == -1)
			return i;  
	} 
	
	return -1; 
} 

"""打印内存中页面的变化"""
void print(int **a, int rnum, int mnum){
	
	int i = 0;
	int k = 0;
	int j;
	
    while(i < mnum)
    {
		for(j = 10 * k; j < rnum; j++)
		{	
				if(j != 10 * (k+1))
				   printf("%d\t", a[i][j]);
			   
				if(j % 10 == 0 && j != 10 * k && i == mnum-1)
				{   
					i=-1;
					k++;
					printf("\n");
					break;
				}
				
				if(j%10==0&&j!=k*10&&i!=mnum-1)
					break;
		}
		
				printf("\n");
				i++;
        
    }
}

"""先进先出页面置换算法FIFO"""
int FIFO(int req[], int rnum, int mnum) 
{  
	int c ount;  
	int i, j;  
	int pos;     

	/*分配内存空间，通常初始化为-1*/
    int *mem = (int *)malloc(sizeof(int ) * mnum);
    setarray(mem, mnum, -1);
	
    /*time记录内存中每个页面进入的时间*/
    int *time = (int *)malloc(sizeof(int) * mnum);
    setarray(time, mnum, rnum);
	
    /*a记录内存中存放的页面*/
    int **a;
    a = (int **)malloc(sizeof(int *) * mnum);
    a[0] = (int *)malloc(sizeof(int) * rnum * mnum);
    for(i = 1; i < mnum; i++)
        a[i] = a[0] + i * rnum;
    initarr(a, mnum, rnum);

	/*缺页次数初始时为 0*/  
	count = 0; 
 
	for (i = 0; i < rnum; i++){   
	
		/*发现页面请求是否存在内存中*/   
		pos = findexist(mem, mnum, req[i]); 
	
		/*如果内存中存在页面请求*/   
		if (pos != -1){
			
			for(j = 0; j < mnum; j++){
				a[j][i+1] = a[j][i];
			}
			/*	
				a[0][i+1] = a[0][i];
				a[1][i+1] = a[1][i];
				a[2][i+1] = a[2][i];	*/
			
			continue;
		}
		
		/*如果内存中不存在缺页次数加一*/   
		count++; 
		
		/*内存中是否存在空位置可以存放新页面*/   
		pos = findempty(mem, mnum); 
		
		/*存在空位置，直接存入新页面，不做置换*/   
		if (pos != -1){
			mem[pos] = req[i];
			time[pos] = i;
			
			a[pos][i] = req[i];
			for(j = 0; j < mnum; j++){
				a[j][i+1] = a[j][i];
			}
            /*	a[0][i+1] = a[0][i];
				a[1][i+1] = a[1][i];
				a[2][i+1] = a[2][i];	*/

			continue;
		}
	
		/*不存在空位置，寻找要置换的页面，fifo*/
		pos = 0;
		
		for (j = 1; j < mnum; j++){
			if (time[j] < time[pos]){
				pos = j;
				}
		}
		
		mem[pos] = req[i];
		time[pos] = i;
		a[pos][i] = req[i];
        if(i < rnum-1)	//防止数组越界
        {
			for(j = 0; j < mnum; j++){
				a[j][i+1] = a[j][i];
			}
			/*	a[0][i+1] = a[0][i];
				a[1][i+1] = a[1][i];
				a[2][i+1] = a[2][i];	*/
        }
	} 
	
	for(j = 1; j < mnum; j++){
		a[j][0] = -1;
	}
	
	/*打印内存中页面的变化*/
	print(a, rnum, mnum);

	free(time);		//释放内存空间
	free(mem);
	free(a);
	
	return count;	//返回缺页次数
	
}

```

