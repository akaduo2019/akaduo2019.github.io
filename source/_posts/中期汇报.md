---
title: 中期汇报
date: 2021-11-10 13:00
tags:
- 中期总结
categories:
- 杂项
---

#  1.reveal.js编写ppt播放页面

##  1.1 reveal.js

reveal.js是一个展示内容的框架，可以理解为WEB版的ppt。

- 和传统的ppt相比，reveal.js的优势体现在：

  - UI风格简洁优美，对数学公式、代码、多媒体扩展支持

  - 制作灵活、不限应用，只需修改HTML文件

  - 丰富的特性，支持过渡动画、代码高亮、markdown语法等

  - 极度轻量，占用空间和内存小

    

## 1.2 reveal.js的使用

- 链接reveal.js相关样式

  ```html
  <link rel="stylesheet" href="{% static 'dist/reset.css' %}">
  <link rel="stylesheet" href="{% static 'dist/reveal.css' %}">
  <link rel="stylesheet" href="{% static 'dist/theme/black.css' %}">
  
  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="{% static 'plugin/highlight/monokai.css' %}">
  ```

- 主体部分

  ```html
  <div class="reveal">
      <div class="slides">
          <section>
              slide1
          </section>
          <section>
              slide2
          </section>
  ```

  一个section标签代表一张PPT页面

## 1.3 reveal.js的事件监听

搭建网站的初衷是为了获得用户的点击流行为日志数据，而在PPT播放页面的体现就是用户点击翻页，浏览器则向服务器发送httprequest请求，服务器接收请求，从而获得诸如请求人ip、path等并作为用户日志信息存储。

而revael.js的slidechanged事件可以很好的做到这一点：

```js
Reveal.addEventListener( 'slidechanged', function( event ) {
                 
            });
```



 # 2 配置django的session模块

在settings.py中添加:

```python
# session 设置
SESSION_EXPIRE_AT_BROWSER_CLOSE = True  # 是否关闭浏览器使得Session过期（默认False）
SESSION_SAVE_EVERY_REQUEST = True  # 是否每次请求都保存Session，默认修改之后才保存（默认False）
```

其作用是已经登录的用户每次关闭浏览器后，再次进入网站，需要再次输入用户名和密码进行登录。

# 3 个人中心修改密码

- view.py

  ```python
  class UpdatePwdView(View):
      def post(self, request):
          modify_form = ModifyPwdForm(request.POST)
          if modify_form.is_valid():
              pwd1 = request.POST.get("password1", "")
              pwd2 = request.POST.get("password2", "")
              if pwd1 != pwd2:
                  return HttpResponse('{"status":"fail","msg":"密码不一致"}',  content_type='application/json')
              user = request.user
              user.password = make_password(pwd2)
              user.save()
  
              return HttpResponse('{"status":"success"}', content_type='application/json')
          else:
              return HttpResponse(json.dumps(modify_form.errors), content_type='application/json')
  ```

  

- urls.py

  ```python
  path("update/pwd/", UpdatePwdView.as_view(),name='update_pwd'),
  ```

  

- js

  ```js
  $(function(){
      //个人资料修改密码
      $('#jsUserResetPwd').on('click', function(){
          Dml.fun.showDialog('#jsResetDialog', '#jsResetPwdTips');
      });
  
      $('#jsResetPwdBtn').click(function(){
          $.ajax({
              cache: false,
              type: "POST",
              dataType:'json',
              url:"/users/update/pwd/",
              data:$('#jsResetPwdForm').serialize(),
              async: true,
              success: function(data) {
                  if(data.password1){
                      Dml.fun.showValidateError($("#pwd"), data.password1);
                  }else if(data.password2){
                      Dml.fun.showValidateError($("#repwd"), data.password2);
                  }else if(data.status == "success"){
                      Dml.fun.showTipsDialog({
                          title:'提交成功',
                          h2:'修改密码成功，请重新登录!',
                      });
                      Dml.fun.winReload();
                  }else if(data.msg){
                      Dml.fun.showValidateError($("#pwd"), data.msg);
                      Dml.fun.showValidateError($("#repwd"), data.msg);
                  }
              }
          });
      });
  ```

  

  

# 4 自定义Middleware+logging配置日志模块

- settings.py

  - MIDDLEWARE注册

    ```python
    MIDDLEWARE = [
        
        ...
        
    	# 自定义
    	'midlog.LogMiddleware.OpLog_Mid',
    ]
    ```

  - logging配置

    formatters、filters、handlers、loggers的配置

    ```python
    # 日志配置
    LOGGING = {
        'version': 1,
        'disable_existing_loggers': False,  # 是否禁用日志器
    
        'formatters': {
            'verbose': {
                'format': '%(levelname)s %(message)s'
            },
            'simple': {
                'format': '  %(message)s'
            },
        },
    
        # 过滤器
        'filters': {
            'require_debug_true': {
                '()': 'django.utils.log.RequireDebugTrue',  # 过滤掉调试信息'
            },
            'skip_static_requests': {
                '()': 'django.utils.log.CallbackFilter',
                'callback': 'skip_static_requests'
            },
        },
        # 处理错误信息的对象
        'handlers': {
            'console': {
                        'level': 'INFO',
                        'class': 'logging.handlers.RotatingFileHandler',
                        'filename': os.path.join(LOG_DIR, 'Info'),
                        'backupCount': 5,
                        'encoding': 'utf-8',
                        'formatter': 'verbose'
            },
            'file': {
                        'level': 'WARNING',  # 记录WARNING级别以上的报错信息
                        'class': 'logging.handlers.RotatingFileHandler',
                        'filename': os.path.join(LOG_DIR, 'Warning'),
                        'backupCount': 5,
                        'formatter': 'verbose'
            }
    
        },
        'loggers': {
                # 日志器名
                'ClickStream': {
                    'handlers': ['console', 'file'],
                    'level': 'INFO'
                },
            }
    }
    ```

- Middleware

  从request中获得请求时间、请求IP、请求人、请求路径、请求方法和请求参数

  ```python
  logger = logging.getLogger('ClickStream')
  
  
  class OpLog_Mid(MiddlewareMixin):
      __exclude_urls = ['index/']  # 定义不需要记录日志的url名单
  
      def process_request(self, request):
          # 存放请求过来时的时间
          request.init_time = time.time()
          return None
  
      def process_response(self, request, response):
          # 请求时间
          re_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime())
  
          # 请求IP
          x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
          if x_forwarded_for:
              # 如果有代理，获取真实IP
              re_ip = x_forwarded_for.split(",")[0]
          else:
              re_ip = request.META.get('REMOTE_ADDR')
  
          # 请求人
          re_user = request.user.username
  
          # 请求路径
          re_path = request.path
          # 请求方法
          re_method = request.method
  
          # 请求参数
          re_content = request.GET if re_method == 'GET' else request.POST
          if re_content:
              # 筛选空参数
              re_content = json.dumps(re_content)
          else:
              re_content = None
  
          message = '%s %s %s %s %s %s' % (re_time, re_ip, re_user, re_path, re_method, re_content)
  
          logger.info(message)
  
          return response
  ```

  

