<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Akaduo Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://akaduo2019.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="第一章 操作系统概论1 什么是操作系统操作系统的作用和定义（p11）(要点1) 作用  服务用户观点——操作系统作为用户接口和公共服务程序  进程交互观点——操作系统作为进程执行的控制者和协调者  系统实现观点——操作系统作为扩展机或虚拟机 裸机提供的是机器语言接口  资源管理观点——操作系统作为资源的管理者和控制者    定义 操作系统是一组有效管理和控制计算机硬件和软件资源，合理组织计算机工作">
<meta name="keywords" content="note">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统期末复习总汇">
<meta property="og:url" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;index.html">
<meta property="og:site_name" content="Akaduo Blog">
<meta property="og:description" content="第一章 操作系统概论1 什么是操作系统操作系统的作用和定义（p11）(要点1) 作用  服务用户观点——操作系统作为用户接口和公共服务程序  进程交互观点——操作系统作为进程执行的控制者和协调者  系统实现观点——操作系统作为扩展机或虚拟机 裸机提供的是机器语言接口  资源管理观点——操作系统作为资源的管理者和控制者    定义 操作系统是一组有效管理和控制计算机硬件和软件资源，合理组织计算机工作">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E7%94%A8%E6%88%B7%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E4%B8%AD%E6%96%AD%E6%BA%90%E7%A7%8D%E7%B1%BB.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%BB%84%E6%88%90.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%E7%9A%844%E4%B8%AA%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%B8%BB%E4%BD%93%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%89%93%E5%8D%B0%E6%9C%BA.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%87%E5%88%86.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E9%A1%B5%E7%9A%84%E5%85%B1%E4%BA%AB.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E9%A1%B5%E7%9A%84%E4%BF%9D%E6%8A%A4.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%B6%8A%E7%95%8C%E4%BF%9D%E6%8A%A4.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%88%86%E9%A1%B5VS%E5%88%86%E6%AE%B5.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A81.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;MMU%E5%8A%9F%E8%83%BD%E6%89%A9%E5%85%85.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;IO%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%A0%BC%E5%BC%8F%E5%8C%96.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%96%87%E4%BB%B6%E8%AE%B0%E5%BD%95%E7%9A%84%E6%88%90%E7%BB%84%E4%B8%8E%E5%88%86%E8%A7%A3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%88%86%E5%8C%BA%E5%92%8C%E7%9B%AE%E5%BD%95.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E7%B4%A2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E7%B4%A22.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E5%B0%8F%E6%80%BB%E7%BB%93.png">
<meta property="og:updated_time" content="2022-01-10T18:37:55.093Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;akaduo2019.github.io&#x2F;2021&#x2F;12&#x2F;29&#x2F;%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87&#x2F;%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91.png">

<link rel="canonical" href="http://akaduo2019.github.io/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>操作系统期末复习总汇 | Akaduo Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>
</head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/akaduo2019" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Akaduo Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">知识、思想、信仰</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://akaduo2019.github.io/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E7%A2%87%E7%9C%9F%E5%97%A3.jpg">
      <meta itemprop="name" content="akaduo">
      <meta itemprop="description" content="克服惰性">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Akaduo Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统期末复习总汇
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 19:55:08" itemprop="dateCreated datePublished" datetime="2021-12-29T19:55:08+08:00">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-11 02:37:55" itemprop="dateModified" datetime="2022-01-11T02:37:55+08:00">2022-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/os/" itemprop="url" rel="index">
                    <span itemprop="name">os</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1><span id="第一章-操作系统概论">第一章 操作系统概论</span></h1><h2><span id="1-什么是操作系统">1 什么是操作系统</span></h2><h3><span id="操作系统的作用和定义p11要点1">操作系统的作用和定义（p11）(要点1)</span></h3><ul>
<li><p>作用</p>
<ul>
<li><p>服务用户观点——操作系统作为用户接口和公共服务程序</p>
</li>
<li><p>进程交互观点——操作系统作为进程执行的控制者和协调者</p>
</li>
<li><p>系统实现观点——操作系统作为扩展机或虚拟机</p>
<p>裸机提供的是机器语言接口</p>
</li>
<li><p>资源管理观点——操作系统作为资源的管理者和控制者</p>
</li>
</ul>
</li>
<li><p>定义</p>
<p>操作系统是一组有效管理和控制计算机硬件和软件资源，合理组织计算机工作流程和为用户有效使用计算机提供良好运行环境的<strong>系统软件</strong>。</p>
</li>
</ul>
<a id="more"></a>

<h2><span id="2-操作系统的演进和分类">2 操作系统的演进和分类</span></h2><h3><span id="操作系统的演进p16">操作系统的演进（p16）</span></h3><ul>
<li><p>第一代 真空管和穿孔卡片</p>
</li>
<li><p>第二代 晶体管和批处理系统</p>
</li>
<li><p>第三代 集成电路和多道程序设计</p>
<p>20世纪50年代，终端和通道技术取得突破性进展，使得计算机体系结构由原先以CPU为中心变成以内存为中心。</p>
<p>通道技术、中断技术和大容量磁盘的出现促成了I/O和计算的并行，多道程序设计浮出水面</p>
<ul>
<li>通道技术 实现了硬件之间的并行性</li>
<li>中断技术 实现了多道程序的切换</li>
<li>多道程序系统<ul>
<li>允许多个作业同时进入一个计算机系统的内存并启动交替计算的发方</li>
<li>引入的根本目的：提高CPU的利用率</li>
<li>现代操作系统的基石</li>
</ul>
</li>
</ul>
</li>
<li><p>第四代 微机操作系统</p>
</li>
<li><p>第五代 手机和嵌入式操作系统 移动计算</p>
</li>
</ul>
<h3><span id="多道程序系统剖析p17-ppt-p32考点113">多道程序系统剖析（p17 PPT p32）(考点1/13)</span></h3><ul>
<li>单道程序OS vs 多道程序OS<ul>
<li>单道程序OS<ul>
<li>内存中仅有单个程序在运行，独占系统中所有资源</li>
<li>致使系统中仍有许多资源空闲，设备利用率地，系统性能较差</li>
</ul>
</li>
<li>多道程序OS<ul>
<li>多道程序设计是指允许多个程序同时进入一个计算机系统的内存并启动进行计算的方法</li>
<li>引入多道程序设计技术的根本目的：提高CPU的利用率</li>
</ul>
</li>
</ul>
</li>
<li>结论<ul>
<li>采用多道程序设计技术有效<strong>提高了资源利用率和系统吞吐率</strong>，但这往往是以<strong>牺牲用户的响应时间为代价的</strong>。</li>
<li>多道程序系统的核心问题：共享软硬件资源时的竞争与协作、共享与安全</li>
</ul>
</li>
</ul>
<h3><span id="现代-操作系统的分类p20要点2">现代 操作系统的分类（p20）**(要点2)**</span></h3><ul>
<li><p>批处理操作系统</p>
</li>
<li><p>分时操作系统</p>
</li>
<li><p>实时操作系统</p>
<p>主要特点</p>
<ul>
<li><p>快速处理</p>
</li>
<li><p>提供及时响应</p>
</li>
<li><p>高可靠性</p>
</li>
</ul>
</li>
</ul>
<h2><span id="3-操作系统的功能和特性">3 操作系统的功能和特性</span></h2><h3><span id="计算机系统的组成与运行ppt-p51">计算机系统的组成与运行（PPT p51）</span></h3><h3><span id="操作系统的功能p12">操作系统的功能（p12）</span></h3><p>(概述，在后续章节中会详细介绍)</p>
<ul>
<li><p>处理器管理</p>
<p>按照一定的算法把处理器分配给<strong>进程</strong>，并对其进行有效的管理和控制。</p>
</li>
<li><p>内存管理</p>
<p>为多道程序的运行提供良好的环境，方便用户使用内存，提高内存的利用率以及能<strong>从逻辑上</strong>扩充内存。</p>
</li>
<li><p>设备管理</p>
</li>
<li><p>文件管理</p>
<p>对计算机中的<strong>信息资源</strong>进行管理</p>
</li>
</ul>
<h3><span id="操作系统的特征p13">操作系统的特征（p13）</span></h3><ul>
<li><p><strong>并发性</strong></p>
<ul>
<li><p>两个或两个以上的活动或者事件在同一时间间隔内发生。</p>
</li>
<li><p>并发：两个或多个任务在同一时间<strong>间隔</strong>内发生</p>
</li>
<li><p>并行：两个或多个任务在同一<strong>时刻</strong>发生</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91.png" class></li>
</ul>
</li>
<li><p><strong>虚拟性</strong></p>
<ul>
<li><p>通过某种技术把一个物理实体变成若干个逻辑上的对应物。</p>
</li>
<li><p>实现方式</p>
<ul>
<li>时分复用技术，如CPU</li>
<li>空分复用技术，如虚拟内存</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>共享性</strong></p>
<ul>
<li><p>系统中的资源可供内存中多个并发执行的进程共同使用。、</p>
</li>
<li><p>共享方式</p>
<ul>
<li><p>透明资源共享，如磁盘、内存、CPU、打印机等</p>
</li>
<li><p>独占资源共享，如磁带机、共享变量、共享缓冲区等</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异步性(不确定性)</strong></p>
<ul>
<li>在多道程序环境下，程序<strong>执行过程</strong>的<strong>不确定性</strong><ul>
<li>何时执行</li>
<li>实行顺序</li>
<li>完成运行所需时间</li>
</ul>
</li>
<li>通常而言，操作系统的不确定性是指异步性，即执行过程的不确定性，而非程序执行结果的不确定性。</li>
</ul>
</li>
<li><p>总结</p>
<p>操作系统的并发性、共享性、异步性、虚拟性四个特征不是相互独立的，具有密切的关系：并发和共享是操作系统的两个最基本的特征，它们又是互为存在的条件。虚拟技术为共享提供了更好的条件，而并发与共享是导致异步性的根本原因。</p>
</li>
</ul>
<h2><span id="4-操作系统的服务和用户接口">4 操作系统的服务和用户接口</span></h2><h3><span id="基本服务p23">基本服务（p23）</span></h3><ul>
<li>提供用户功能的系统服务</li>
<li>确保系统本身高效运行的服务</li>
</ul>
<p>用户如何使用这些服务呢？通过用户接口。</p>
<h3><span id="用户接口p24-ppt-p76要点3">用户接口（p24 PPT p76）(要点3)</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E7%94%A8%E6%88%B7%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3.jpg" class>

<ul>
<li><p>操作接口(用户操作)</p>
<ul>
<li><p>CLI(Command Line Interface)</p>
<p>操作系统提供命令解释器，获取用户输入的命令并执行它、</p>
</li>
<li><p>GUI(Graphic User Interface)</p>
<p>用户友好的图形化接口</p>
</li>
<li><p>Touchscreen Interface</p>
<p>触摸屏设备，手势</p>
</li>
</ul>
</li>
<li><p>程序接口(系统调用)——<strong>系统调用是应用程序获得操作系统服务的唯一途径</strong></p>
<ul>
<li><p>何为<strong>系统调用</strong>？system calls</p>
<p><strong>访问和使用操作系统所提供服务的编程接口</strong>。</p>
<ul>
<li>系统调用的代码实现是操作系统级的</li>
<li>一般用C或C++编写，也有用汇编指令编写的</li>
<li>通常系统每秒执行成千上万个系统调用</li>
</ul>
</li>
<li><p>系统调用分类</p>
<p>略</p>
</li>
<li><p>系统调用和API库函数</p>
<p>API指明了参数和返回值的一组函数。API是一个函数定义，它强调的是如何通过接口来获得所需服务，注意<strong>系统调用只是一种API</strong>，而API还包括各种各样的编程接口。</p>
</li>
<li><p>双重模式</p>
<ul>
<li>用户模式：执行用户代码</li>
<li>内核模式：执行操作系统代码</li>
<li>用硬件模式为(mode bit)来表示当前模式，0表示内核模式，1表示用户模式</li>
</ul>
</li>
<li><p>模式切换</p>
<p>当CPU执行程序中编写的由访管指令实现的系统调用时会产生异常信号，通过陷阱机制，处理器的状态由用户态转变为内核态，进入操作系统并执行相应服务例程，以获得操作系统服务。当系统调用执行完毕时，处理器再次切换状态，控制返回至发出系统调用的程序。</p>
<p>系统调用在内核模式下运行。</p>
</li>
</ul>
</li>
</ul>
<h2><span id="5-操作系统的结构和运行模型">5 操作系统的结构和运行模型</span></h2><h3><span id="操作系统的结构p35要点4">操作系统的结构（p35）(要点4)</span></h3><p>阐述操作系统的整体结构，如功能如何分块，模块之间如何交互等。</p>
<ul>
<li><p>宏内核结构(又称单体式结构)</p>
<ul>
<li>主要设计思想和步骤：把<strong>模块</strong>作为操作系统的基本单位，按照<strong>功能</strong>需要把整个系统<strong>分解</strong>为若干模块，每个模块具有一定独立功能，若干个关联模块协作完成某个功能，明确各个模块之间的接口关系，各个模块间可以不加控制自由调用，所以又叫无序调用法；数据多数作为全程量使用；模块之间需要传递参数或返回结果时，其个数和方式也可根据需要随意约定；然后分别设计、编码、调试各个模块；最后把所有模块连接成一个完整的单体系统。</li>
<li>优点<ul>
<li>结构紧密，执行效率高</li>
</ul>
</li>
<li>缺点<ul>
<li>内核包含大量功能，难以设计和实现</li>
<li>模块独立性差，可靠性低</li>
<li>系统功能增、减十分困难</li>
</ul>
</li>
<li>例子：Linux</li>
</ul>
</li>
<li><p>层次式结构</p>
<ul>
<li>基本思路：将操作系统划分为内核和若干模块，这些模块按照功能的调用次序排列成若干层次<strong>，各层之间只能存在单向依赖或单向调用关系</strong>，即低层为高层提供服务，高层可以调用低层，反之则不能。</li>
<li>优点<ul>
<li>调用关系清晰(高层对低层单向依赖)</li>
<li>低层和高层可分别实现(可扩充性)</li>
<li>高层错误不会影响到低层(正确性)</li>
</ul>
</li>
<li>缺点<ul>
<li>部分功能很难分清谁上谁下，如处理器调度和存储管理</li>
<li>降低了系统运行效率</li>
</ul>
</li>
<li>例子：层次式操作系统鼻祖——THE操作系统</li>
</ul>
</li>
<li><p>虚拟机结构</p>
<ul>
<li><p>设计思想：</p>
<p>利用多重化和共享技术把一个裸机改编成若干个逻辑上的对应物；</p>
<p>每台虚拟机包含内核态/用户态、终端、CPU、I/O设备、内存、外存等全部不见，功能和裸机相同，可以运行裸机能够运行的任何操作系统，不同虚拟机可以运行不同操作系统</p>
</li>
</ul>
</li>
<li><p>微内核结构</p>
<ul>
<li><p>采用客户/服务器模型</p>
<p>内核仅实现最基本功能：虚拟存储、消息传递、进程控制、设备驱动</p>
<p>其余更多系统功能放在内核之外：独立服务进程运行方式、等待和响应客户进程提出的请求</p>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li><strong>对进程的请求提供一致性接口</strong>，不必区分内核及服务和用户及服务，所有服务均借助消息传递机制提供</li>
<li>具有较好的<strong>可扩充性和易修改性</strong>，增加新服务或替换老功能只需增加或替换服务器</li>
<li><strong>可移植性好</strong>，与特定CPU有关的代码均在微内核中，把系统移植到新平台所做的修改较小</li>
<li><strong>对分布式系统提供有力支撑</strong></li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>运行效率较低</strong>，进程间必须通过内核的通信机制(消息传递机制)才能进行通信</li>
</ul>
</li>
</ul>
</li>
<li><p>混合系统</p>
<ul>
<li>混合内核很像微内核结构，只不过它有更多的对系统性能影响很大的系统组件在内核态运行，以获得更快的执行速度。</li>
<li>典型系统<ul>
<li>Windows：层次式+混合内核+可加载内核模块</li>
<li>Max OS：层次式+混合内核+可加载内核模块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id="操作系统内核的原语p40要点5">操作系统内核的原语（p40）(要点5)</span></h3><ul>
<li><p>原语管理</p>
<ul>
<li><p>原语是内核中实现特定功能的不可中断过程。</p>
<p>例如，通信原语实现进程相互传递消息，同步原语能协调进程间的制约关系，IO设备原语实现设备驱动和文件传输等。</p>
</li>
<li><p>原语的实现方法之一是以系统调用的方式提供原语接口，采用屏蔽中断的方式来实现，以保证原语操作不被中断的特性。</p>
</li>
<li><p>原语和系统调用</p>
<p>同：</p>
<ul>
<li>原语和系统调用都使用访管指令(机器指令)实现，具有相同的调用形式</li>
</ul>
<p>异：</p>
<ul>
<li>但原语由内核实现，而系统调用由系统实现；</li>
<li>原语不可被中断，而系统调用允许被中断。</li>
</ul>
</li>
<li><p>原语通常供系统进程使用，系统进程向实用程序提供系统调用，而实用程序向应用程序提供高层功能</p>
</li>
</ul>
</li>
</ul>
<h3><span id="操作系统的运行模型-p42">操作系统的运行模型 （p42）</span></h3><ul>
<li>OS服务例程嵌入应用程序中运行</li>
<li>OS服务例程作为独立进程运行</li>
</ul>
<h1><span id="第二章-处理器管理">第二章 处理器管理</span></h1><h2><span id="1-相关背景">1 相关背景</span></h2><h3><span id="特权指令和非特权指令p56要点6">特权指令和非特权指令（p56）(要点6)</span></h3><ul>
<li>指令系统是计算机所能执行的机器指令集合，其中指令分为特权指令和非特权指令。</li>
<li>特权指令<ul>
<li>具备<strong>改变机器状态、修改寄存器内容、启动I/O设备等</strong>特权的机器指令，如设置时钟、控制中断屏蔽位，清内存、加载程序状态字等。</li>
<li>特权指令仅能由操作系统使用。</li>
</ul>
</li>
<li>非特权指令<ul>
<li>指令系统中除了特权指令之外的指令。</li>
<li>非特权指令既可以被操作系统使用，也可以被应用程序使用。</li>
</ul>
</li>
<li>当前程序运行时的处理器模式，决定了当前程序是否能执行特权指令。</li>
</ul>
<h3><span id="处理器的两种模式p56要点7">处理器的两种模式（p56）(要点7)</span></h3><ul>
<li><p>根据运行程序对资源和机器指令的使用权限将处理器工作模式设置为：内核模式和用户模式</p>
</li>
<li><p>内核模式</p>
<ul>
<li>操作系统内核运行的状态，较高的特权级别，可以执行全部指令，直接访问硬件设备和所有内存空间，并具有改变处理器状态的能力，又称为核心态、管态。</li>
</ul>
</li>
<li><p>用户模式</p>
<ul>
<li>用户程序运行时的状态，较低的特权等级，只能执行非特权指令，访问规定的寄存器和存储区，又称为普通态、目态。</li>
</ul>
</li>
<li><p>CPU如何知道当前运行的用户程序还是操作系统？程序状态字</p>
</li>
</ul>
<h3><span id="处理器模式的转换p57">处理器模式的转换（p57）</span></h3><ul>
<li><p>用户模式-&gt;内核模式</p>
<p><strong>中断是CPU从用户模式向核心模式转换的唯一途径。</strong></p>
<p>三种时机</p>
<ul>
<li>用户进程在执行时发生中断事件(如I/O操作完成)，运行程序被中断，转去执行中断处理程序。(中断)</li>
<li>用户进程执行系统调用，请求操作系统服务。(异常)</li>
<li>用户进程在执行时产生错误(甚至不可恢复的致命错误)(如发生程序性中断或目态执行特权指令)，进程被打断，转去执行故障(终止)处理程序。(异常)</li>
</ul>
</li>
<li><p>内核模式-&gt;用户模式</p>
<p>中断处理结束后，执行特权指令(如Intel x86中 iret指令)将用户进程的PSW加载到PSW寄存器，实现从内核模式返回用户模式，CPU的控制权转交给用户程序。</p>
</li>
</ul>
<h3><span id="程序状态字pswp58">程序状态字PSW（p58）</span></h3><ul>
<li><p>PSW用来指示运行程序的状态、控制指令执行的顺序，并且保留和指示与运行程序有关的各种信息。</p>
</li>
<li><p>PSW由标志寄存器和程序计数器的内容组成</p>
<ul>
<li>标志寄存器：状态标志、控制标志和系统标志</li>
<li>程序计数器：正在运行程序的下一条要执行指令的地址</li>
</ul>
</li>
<li><p>每个处理器都设置一个PSW寄存器。每个执行中的程序都有一个与其执行相关的PSW，程序获得处理器执行，它的PSW将占有PSW寄存器。</p>
</li>
<li><p>系统内核程序PSW中的处理器模式位为”内核模式”</p>
<p>用户进程PSW中的处理器模式位为”用户模式”</p>
</li>
</ul>
<h3><span id="中断的概念p58">中断的概念（p58）</span></h3><p>中断指在进程执行过程中遇到继续处理的事件时。暂时中止现行进程在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再返回断点或调度其他进程执行的过程。</p>
<h3><span id="中断源种类p59">中断源种类（p59）</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E4%B8%AD%E6%96%AD%E6%BA%90%E7%A7%8D%E7%B1%BB.png" class>

<ul>
<li>中断  外部中断<ul>
<li>I/O中断</li>
<li>时钟中断</li>
</ul>
</li>
<li>异常  内部中断<ul>
<li>陷阱和系统调用 访管中断 </li>
<li>故障 程序性中断</li>
<li>终止 硬件故障中断</li>
</ul>
</li>
</ul>
<h3><span id="中断系统的构成ppt-p11">中断系统的构成（PPT p11）</span></h3><h3><span id="中断处理过程ppt-p12">中断处理过程（PPT p12）</span></h3><h2><span id="2-进程及其实现">2 进程及其实现</span></h2><h3><span id="进程的定义p71要点8">进程的定义（p71）(要点8)</span></h3><ul>
<li>进程(process）是具有独立功能的程序在某个数据集合上的<strong>一次运行活动</strong>，也是操作系统进行资源分配和保护的基本单元。</li>
<li><strong>进程是由PCB、程序和数据组成的</strong></li>
<li>程序 vs 进程<ul>
<li>程序是存放在外存中可执行文件，是一个被动实体，被加载到内存之后可执行，此时系统将为其创建一个进程。</li>
<li>进程是<strong>执行的程序</strong>。进程需要一定的资源，如CPU事件、内存、文件和I/O设备，以便执行任务。这些资源在创建进程或执行进程时得以分配。</li>
</ul>
</li>
</ul>
<h3><span id="进程状态及转换p73要点9">进程状态及转换（p73）(要点9)</span></h3><ul>
<li><p>进程状态</p>
<p><strong>就绪</strong>(ready)：进程具备运行条件，等待分配CPU。 (就绪队列)</p>
<p><strong>运行</strong>(running)：此时进程的代码在CPU上运行 (小于等于处理器(核)数量)</p>
<p><strong>等待</strong>(wait)：又称<strong>阻塞</strong>(blocked)、<strong>睡眠</strong>(sleep)，进程不具备运行条件，进程在等待某些事件的发生。(等待队列)     比如I/O操作结束或者收到信号 </p>
</li>
<li><p>进程转换</p>
<ul>
<li><p>三态模型</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.jpg" class></li>
<li><p>说明</p>
<ul>
<li><p>进程获得CPU的唯一途径是进程被调度！</p>
</li>
<li><p>进程状态的转换并非都是可逆的进程既不能从等待态变为运行态，也不能从就绪态变为等待态。</p>
</li>
<li><p>一个进程被唤醒意味着它变为就绪态。</p>
</li>
<li><p>进程放弃CPU的两类事件</p>
<ul>
<li><p>主动事件</p>
<p>进程主动放弃CPU，进入等待/终止状态。</p>
<p>比如使用I/O设备，(非)正常结束。</p>
</li>
<li><p>被动事件</p>
<p>进程被剥夺CPU使用权，进入就绪状态。这个动作叫抢占，</p>
<p>比如时间片到，高优先级进程到达。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id="进程映像p75要点10">进程映像（p75）(要点10)</span></h3><p>由于进程状态不太发生变化，某时刻进程的内容及其状态集合称为进程映像，包括以下一些要素：</p>
<ul>
<li>进程控制块</li>
<li>进程程序块</li>
<li>进程核心栈</li>
<li>进程数据块</li>
</ul>
<h3><span id="进程控制块process-control-blockpcbp75要点11">进程控制块(Process Control Block，PCB)（p75）(要点11)</span></h3><ul>
<li><p>定义</p>
<p>进程控制块是操作系统为了管理进程设置的一组专门的<strong>数据结构</strong>，它是一个既能<strong>标识进程的存在</strong>，又能<strong>刻画进程执行瞬间</strong>的诸多特征。</p>
<ul>
<li>系统在创建进程时，为它建立PCB，当进程结束被撤销时，回收其所占用的PCB，PCB是系统感知进程存在的唯一标志。</li>
<li>操作系统根据PCB对并发执行的进程管理和控制，进程借助于PCB才能被调度。</li>
</ul>
</li>
<li><p>组成</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%BB%84%E6%88%90.png" class>

<ul>
<li><p>标识信息</p>
<p>标识信息用于唯一地标识一个进程，分为用户使用的外部标识和系统使用的内部标识号。系统中的所有进程都被赋予唯一的、内部使用的数值型进程号(通常是0~32767的正整数)，操作系统内核函数可通过进程号来引用PCB。常用的标识信息包括进程标识ID、进程组标识ID、用户进程名、用户组名等。</p>
</li>
<li><p>现场信息</p>
<p>现场信息用于保留进程在运行时存放在处理器现场中的各种信息。进程在让出处理器时，必须将此时的现场信息保存到它的PCB中，而当此进程恢复运行时也应恢复处理器现场。现场信息包括通用寄存器内容、控制寄存器内容、栈指针、程序状态字等。</p>
</li>
<li><p>控制信息</p>
<p>控制信息用于管理和调度进程，包括进程调度的相关信息。</p>
</li>
</ul>
</li>
</ul>
<h3><span id="进程队列p76要点12">进程队列（p76）(要点12)</span></h3><ul>
<li>将进程的PCB通过某种方法组织起来。一般来说，把处于同意状态的所有进程的PCB链接在一起的数据结构成为进程队列。<ul>
<li>等待队列</li>
<li>就绪队列</li>
</ul>
</li>
<li>两种通用的队列组织方式<ul>
<li>链接方式</li>
<li>索引方式</li>
</ul>
</li>
</ul>
<h3><span id="进程切换ppt-p37">进程切换（PPT p37）</span></h3><ul>
<li>中断和异常会暂停当前正在执行的进程，把处理器切换至内核模式，在中断处理过程中，由内核决定是否实施进程切换</li>
<li>进程切换的时机<ul>
<li>进程被抢占CPU进入就绪状态，例如时间片到，高优先级进程到达。</li>
<li>进程需要进入等待状态，例如进程执行系统调用请求I/O服务。</li>
<li>进程进入终止状态，如进程正常或非正常结束。</li>
</ul>
</li>
</ul>
<h3><span id="进程控制概述p81">进程控制概述（p81）</span></h3><p>操作系统通过原语来完成进程管理，包括进程控制、进程调度、进程的同步和互斥、进程的通信。</p>
<h2><span id="3-线程及其实现">3 线程及其实现</span></h2><h3><span id="线程概述p83要点13">线程概述（p83）(要点13)</span></h3><ul>
<li><p>线程的引入</p>
<ul>
<li><p>引入多线程的动机</p>
<ul>
<li>如果说操作系统引入进程的目的是为了使多个程序并发执行，以便改善资源利用率和提高系统效率</li>
<li>那么，在进程之后再<strong>引入线程概念</strong>则<strong>是为了减少进程并发执行时所付出的时空开销，使得并发粒度更细、并发性更好</strong></li>
</ul>
</li>
<li><p>思路</p>
<p>把进程的两项功能”独立分配资源”和”被调度分派执行”分离开来，</p>
<ul>
<li>前一项任务仍然由<strong>进程</strong>完成，<strong>作为系统资源分配和保护的独立单位</strong>，无需频繁地切换；</li>
<li>后一项任务交给称作<strong>线程</strong>的实体来完成，线程<strong>作为系统调度和分派的基本单位</strong>，会被频繁地调度和切换。</li>
</ul>
<p>在这种思想的指导下产生了多线程概念，即多线程进程。</p>
</li>
</ul>
</li>
<li><p>线程的优点</p>
<p>与进程相比，线程有如下优点</p>
<ul>
<li><strong>快速线程切换</strong>。同一进程中的多线程切换只需改变堆栈和寄存器，<strong>地址空间不变</strong>。</li>
<li><strong>通信易于实现</strong>。自动共享进程的内存和文件，<strong>线程可自由访问全局数据</strong>，实现数据共享十分方便，<strong>线程通信</strong>相对简单，<strong>不必经过内核</strong>。</li>
<li><strong>减少管理开销</strong>。线程创建和撤销工作比进程少很多，并且无需再分配存储空间和各种资源。</li>
<li><strong>并发程度高</strong>。多线程适宜并行工作，能充分发挥处理器与设备的并行工作能力，使多核和多处理器系统的效能发挥得更好。</li>
</ul>
</li>
<li><p>线程的定义</p>
<ul>
<li><p>一个进程可以包含一个或多个可以并发的线程，系统<strong>按进程分配所有除CPU以外的系统资源</strong>(如内存、外设、文件等)，<strong>线程则作为CPU的分配单位</strong>。</p>
</li>
<li><p>每个线程是CPU使用的一个基本单元，包括<strong>独立的线程ID、PC、寄存器组和栈</strong>。它与同一进程的其他线程<strong>共享</strong>代码段、数据段和其他操作系统资源，如打开的文件和各种信号量。</p>
</li>
<li><p> Tip：</p>
</li>
</ul>
<p>  <strong>线程是进程内的一个相对独立的执行单元，但不能独立运行，只能在进程中运行。</strong></p>
<p>  同一个进程中的线程切换不会引起进程切换，当从一个进程中的线程切换到另一个进程中的线程    时，将会引起进程的切换</p>
</li>
<li><p>线程控制块(Thread Control Block，TCB)</p>
<p>组成部分</p>
<ul>
<li><p>线程标识符</p>
</li>
<li><p>处理器状态信息</p>
<p>程序计数器、栈指针，寄存器组值等</p>
</li>
<li><p>调度信息</p>
<p>线程状态(运行、就绪、等待)、时间片、CPU事件、优先级等</p>
</li>
<li><p><strong>指向PCB的指针</strong></p>
</li>
</ul>
</li>
<li><p>线程的应用(不记也罢)</p>
<ul>
<li>一个应用程序作为具有多个控制线程的一个进程来实现</li>
<li>单个应用程序的多个线程分别为不同用户完成相同服务</li>
<li>多个线程在内核中运行，每个线程执行一个特定任务</li>
</ul>
</li>
</ul>
<h3><span id="线程的实现p85要点14">线程的实现（p85）(要点14)</span></h3><ul>
<li><p>线程的分类</p>
<ul>
<li>内核级线程<ul>
<li>在操作系统内核(<strong>内核级线程库</strong>：库内代码和数据结构位于内核空间)的支持下，创建、销毁和管理线程。</li>
<li>内核为进程和进程内的每个线程维护上下文，调度由内核<strong>基于内核级线程</strong>完成。<ul>
<li>当进程中的一个线程阻塞时，内核可以调度同一个进程中的另一个线程；</li>
<li>内核可以同时把一个进程多个线程调度到多个处理器上执行</li>
</ul>
</li>
<li>几乎所有的现代操作系统都支持内核级线程，包括Windows，Linux，Mac OS和Solaris。</li>
</ul>
</li>
<li>用户级线程<ul>
<li>由用户进程通过执行<strong>用户级线程库</strong>(在用户空间提高一个没有内核支持的线程库，库中所有代码和数据结构都位于用户空间)API创建、销毁和管理的线程</li>
<li>在用户模式下运行，其管理无需内核支持，创建和管理非常快。</li>
<li>纯ULT系统，内核<strong>以进程为单位</strong>进行调度。<ul>
<li>任何一个用户级线程执行一个导致阻塞的系统调用，都会导致整个进程阻塞；</li>
<li>无法实现同一进程中多个线程的并发执行。</li>
</ul>
</li>
</ul>
</li>
<li>混合式线程</li>
</ul>
</li>
<li><p>线程库(thread library)</p>
<p>为程序员提高创建和管理线程的API</p>
</li>
<li><p>多线程模型</p>
<p>略</p>
</li>
</ul>
<h2><span id="4-处理器调度">4 处理器调度</span></h2><h3><span id="处理器调度的层次p94">处理器调度的层次（p94）**</span></h3><ul>
<li><p>高级调度(又称作业调度、长程调度)</p>
<ul>
<li>在批处理系统或操作系统的批处理部分中，<strong>新提交的作业会发送到外存</strong>，并保存在一个后备队列中。</li>
<li>高级调度按一定的原则从<strong>外存上</strong>处于后备队列的作业中选择一个或多个，给它们<strong>分配内存、I/O设备等</strong>必要的资源，并<strong>建立</strong>相应的<strong>进程</strong>，以使该作业具有获得竞争处理器的权利。</li>
</ul>
</li>
<li><p>中级调度(又称交换调度、中程调度)</p>
<ul>
<li>为提高内存利用率和系统吞吐量，应使那些<strong>暂时不能运行的进程</strong>(等待态或就绪态)放弃占用内存资源，即调至<strong>外存对换区</strong>等待;       <strong>挂起(suspend)</strong></li>
<li>当内存稍有空闲时，可将外存对换区中那些具备运行条件的进程重新调入内存，修改其状态，挂到<strong>就绪进程队列</strong>等待进程调度。</li>
<li>挂起的进程等同于<strong>不在内存的进程</strong>。</li>
</ul>
</li>
<li><p>低级调度(进程调度、短程调度)</p>
<ul>
<li>按照某种策略从就绪队列中选取一个进程，将处理器分配给它。</li>
<li>进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。</li>
<li>进程调度是操作系统最核心的部分，执行十分频繁，进程调度策略的优略直接影响到整个系统的性能。</li>
<li>线程调度：内核级线程取代进程作为基本的CPU单位，用户级线程为了运行在CPU上，须映射到相关的内核级线程。</li>
</ul>
</li>
<li><p>在上述三级调度中，低级调度是各类操作系统的必备功能，在纯粹分时操作系统或实时操作系统中通常不需要高级调度。一般操作系统都配置高级调度和低级调度，而功能完善的操作系统为了提高内存利用和作业吞吐量引进了中级调度。</p>
</li>
<li><p>调度队列模型</p>
<ul>
<li>仅有进程调度的调度队列模型</li>
<li>具有作业和进程调度的调度列模型</li>
<li>同时具有三级调度的调度队列模型</li>
</ul>
</li>
<li><p>进程调度方式</p>
<ul>
<li>抢占/剥夺调度方式</li>
<li>非抢占/非剥夺调度方式</li>
</ul>
</li>
</ul>
<h3><span id="选择调度算法的基本原则p95要点15">选择调度算法的基本原则（p95）(要点15)</span></h3><ul>
<li><p>系统层面</p>
<ul>
<li><p>CPU利用率</p>
<p>CPU利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)</p>
</li>
<li><p>系统吞吐量</p>
<p>单位时间内CPU完成作业的数量。</p>
</li>
</ul>
</li>
<li><p>用户层面</p>
<ul>
<li><p><strong>周转时间</strong></p>
<ul>
<li><p>一个进程<strong>从提交到完成之间的时间间隔</strong>，包括实际执行时间和等待资源的时间。</p>
</li>
<li><p>批处理系统重要指标。</p>
</li>
</ul>
</li>
<li><p>响应时间</p>
<ul>
<li><p>从用户提交请求到系统首次产生响应所用的时间，</p>
</li>
<li><p>分时系统和实时系统重要指标</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调度算法的衡量指标</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4.png" class></li>
</ul>
<h3><span id="低级调度功能和类型p99">低级调度功能和类型（p99）</span></h3><h3><span id="经典调度算法p100107-ppt-p87110考点213">经典调度算法（p100<del>107 PPT p87</del>110）(考点2/13)</span></h3><ul>
<li>先来先去服务算法(First Come First Served，FCFS)<ul>
<li>选择最先进入就绪队列的进程投入执行，即进程按照请求CPU的顺序使用CPU。</li>
<li>非抢占调度方式</li>
</ul>
</li>
<li>最短作业优先算法(Shortest Job First，SJF)<ul>
<li>已进入系统作业所要求的CPU时间长短为准，总是选取时间要求最短的投入运行</li>
<li>SJF是一个非抢占式算法，也可以改成抢占式SRTF</li>
</ul>
</li>
<li>最短剩余时间优先算法(Shortest Remaing Time First，SRTF)<ul>
<li>如果一个新就绪进程所需的CPU时间比当前正在执行的进程所剩余时间短，那么新进程将抢占CPU。</li>
<li>抢占调度方式</li>
</ul>
</li>
<li>最高响应优先比算法(Hight Response Ratio First, HRRF)<ul>
<li><p>在调度时，综合考虑作业的等待事件和执行时间</p>
<p>响应比=响应时间/执行时间=(执行时间+等待时间)/执行时间=1+等待时间/执行时间</p>
<p>响应比越高，越优先。</p>
</li>
<li><p>非抢占</p>
</li>
<li><p>短、长作业都考虑到了</p>
</li>
</ul>
</li>
<li>优先级调度算法(Priority)<ul>
<li>每个进程被赋予一个优先级，允许优先级最高的就绪进程先被调度</li>
<li>系统可预先规定策略为非抢占式还是抢占式<ul>
<li>非抢占式调度：当前进程继续允许，知道它结束或者出现等待事件而主动让出处理器，在调度另一个优先高的进程/线程运行。</li>
<li>抢占式调度：当就绪队列中出现高优先级进程时，立即重新调度，剥夺当前进程所占用的处理器。</li>
</ul>
</li>
</ul>
</li>
<li>时间片轮转算法(Round Robin，RR)<ul>
<li>每个进程被分配一个时间片，如果在时间片结束时该进程还在运行，则剥夺其CPU并分配给另一个进程，被剥夺的CPU进程则插入就绪队列末尾，等待下次调度；如果该进程在时间片内阻塞或结束，则立即切换CPU。</li>
<li>抢占调度方式</li>
</ul>
</li>
<li>多级反馈队列调度(MLFQ)<ul>
<li>采用”<strong>惩罚长进程</strong>“的思想。根据进程执行<strong>历史</strong>，调度基于抢占原则并采取动态优先级机制，可以获得较好的性能</li>
<li>抢占式</li>
</ul>
</li>
</ul>
<h1><span id="第三章-同步-通信与死锁">第三章 同步、通信与死锁</span></h1><h2><span id="1-进程同步">1 进程同步</span></h2><h3><span id="无关进程和交互进程p125">无关进程和交互进程（p125）</span></h3><ul>
<li>无关进程<ul>
<li>并发进程分别在自己的变量集合上运行</li>
<li>无关进程可能会<strong>竞争</strong>使用独占资源</li>
</ul>
</li>
<li>交互进程<ul>
<li>并发进程执行过程中需要共享和交换数据</li>
<li>交互的并发进程之间存在<strong>竞争</strong>和<strong>协作</strong>两种关系</li>
</ul>
</li>
</ul>
<h3><span id="竞争关系进程互斥死锁饥饿p128要点16">竞争关系(进程互斥/死锁/饥饿)（p128）(要点16)</span></h3><h3><span id="协作关系进程同步通信制约p129要点17">协作关系(进程同步/通信/制约)（p129）(要点17)</span></h3><ul>
<li><p>进程的同步与互斥</p>
<ul>
<li><p>互斥</p>
<p>并发进程间因<strong>竞争独占型资源资源</strong>而引起的，为一个进程等待另一个进程已经占有的、必须互斥使用的资源时的一种制约关系(间接制约)。</p>
</li>
<li><p>同步</p>
<p>并发进程间需要<strong>协调完成同一任务</strong>时引起的一种关系，为一个进程等待另一个进程向它直接发送消息或数据时的一种制约关系(直接制约)。</p>
</li>
<li><p>互斥是一种特殊的同步，即逐次使用互斥资源。因此解决同步问题的方法同样能解决互斥问题，反之并不成立。</p>
</li>
</ul>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5.png" class></li>
</ul>
<h3><span id="临界区及其使用p129">临界区及其使用（p129）</span></h3><ul>
<li><p>临界资源</p>
<ul>
<li>一次只能供一个进程使用的资源。<ul>
<li>许多物理设备都属于临界资源，如打印机、扫描仪等。</li>
<li>许多可被多个进程共享的变量和文件也属于临界资源。</li>
</ul>
</li>
<li>对于临界资源的访问必须采用<strong>互斥方式。</strong></li>
</ul>
</li>
<li><p>临界区(又叫互斥区)</p>
<ul>
<li><p>在并发进程中，<strong>访问临界资源的程序段</strong>。</p>
</li>
<li><p>为了保证临界资源的正确使用，可以把临界资源的访问过程分为4个部分：</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE%E7%9A%844%E4%B8%AA%E8%BF%87%E7%A8%8B.png" class></li>
</ul>
</li>
<li><p>临界区使用原则</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99.png" class></li>
</ul>
<h3><span id="实现临界区互斥的软件方法p131">实现临界区互斥的软件方法（p131）</span></h3><h3><span id="实现临界区互斥的硬件方法p132">实现临界区互斥的硬件方法（p132）</span></h3><h3><span id="信号量与pv操作ppt-p37考点313">信号量与PV操作（PPT p37）(考点3/13)</span></h3><ul>
<li><p>信号量(semaphore)</p>
<p>信号量时一个数据结构，负责协调各个进程，以保证它们能够正确、合理地使用公共资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;        <span class="comment">//信号量的值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcb</span>* <span class="title">list</span>;</span> <span class="comment">//信号量等待队列指针</span></span><br><span class="line">&#125;semaphore;</span><br><span class="line">semaphore s;</span><br></pre></td></tr></table></figure>

<p>信号量代表对某种公共资源的管理，其初值是一个非负整数，代表<strong>资源的数量</strong>。</p>
<p>要使用资源的进程需通过信号量申请:有资源时顺利通过；若没有资源可用，则进程将<strong>进入对于信号量的等待队列</strong>。</p>
<p>当一个进程归还资源时，此时若信号量队列有等待进程则<strong>唤醒</strong>一个。</p>
</li>
<li><p>PV操作</p>
<ul>
<li><p>PV操作的功能</p>
<ul>
<li><p>P操作用于<strong>申请</strong>信号量管理的资源。</p>
<p>信号量的值<strong>减1</strong></p>
<p><strong>有条件阻塞自己</strong></p>
</li>
<li><p>V操作用于释放<strong>资源</strong></p>
<p>信号量的值<strong>加1</strong></p>
<p><strong>有条件唤醒其他进程</strong></p>
</li>
<li><p>PV操作均是低级进程通信原语，执行过程不可中断。</p>
<p>除了初始化之外，PV操作时两个唯一能对信号量的值进行处理的操作。</p>
</li>
</ul>
</li>
<li><p>PV原语实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(semaphore s)</span></span>&#123;</span><br><span class="line">s.value = s.value<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)</span><br><span class="line">	sleep(s.<span class="built_in">list</span>); <span class="comment">//资源不足则阻塞自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(semaphore s)</span></span>&#123;</span><br><span class="line">s.value = s.value+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (s.value &lt;= <span class="number">0</span>)</span><br><span class="line">	wakeup(s.<span class="built_in">list</span>); <span class="comment">//有进程等待资源则唤醒"他人"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结 信号量机制用于资源共享时的含义</p>
</li>
</ul>
</li>
</ul>
<h3><span id="用信号量机制实现进程互斥ppt-p41~43">用信号量机制实现进程互斥（PPT p41~43）</span></h3><ul>
<li>互斥信号量</li>
<li>计数信号量</li>
<li>哲学家就餐问题</li>
</ul>
<h3><span id="用信号量机制实现进程同步ppt-p47~69">用信号量机制实现进程同步（PPT p47~69）</span></h3><ul>
<li><p>基本思路(司机-售票员问题)</p>
<ul>
<li><p>同步问题实质上时<strong>让那些随即发生的事件变得有序</strong>。</p>
</li>
<li><p>实现方法是<strong>调节进程的执行速度</strong>，让某些进程必须<strong>等待</strong>另一些进程的执行而得以继续。</p>
</li>
<li><p>在<strong>同步</strong>问题里，我们利用<strong>执行P原语会引发等待</strong>的效果来实现交接并发进程执行速度的目标。</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5.png" class></li>
</ul>
</li>
<li><p>生产者-消费者问题</p>
<ul>
<li><p><strong>单缓冲区问题</strong></p>
</li>
<li><p><strong>有界缓冲区问题</strong></p>
<ul>
<li><p>互斥信号量 mutex</p>
<p>互斥信号量引入是为了解决多个生产者和消费者同时进入临界区的问题(互斥问题)；</p>
<p>**互斥信号量初值设置为1，进入临界区之前P(mutex)，出临界区之后V(mutex)**。</p>
</li>
</ul>
</li>
<li><p>信号量机制使用注意事项</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.png" class></li>
<li><p>同步问题分析过程</p>
<ul>
<li>有几个并发进程，公用缓冲区个数。</li>
<li>分析每个进程的执行流程，必要时画出它的流程图，找出在何时何出需要等待。</li>
<li>设置几个信号量？信号量初值设成多少？需要其他变量辅助吗？</li>
<li>公用缓冲区是否需要互斥信号量保护？</li>
</ul>
</li>
</ul>
</li>
<li><p>苹果-桔子问题</p>
</li>
<li><p><strong>读者-写者问题(看一手)</strong></p>
</li>
<li><p>理发师问题</p>
</li>
</ul>
<h2><span id="2-进程通信">2 进程通信</span></h2><h3><span id="进程通信概述p151要点19">进程通信概述（p151）(要点19)</span></h3><h3><span id="管道通信机制p155">管道通信机制（p155）</span></h3><h3><span id="共享内存通信机制p156">共享内存通信机制（p156）</span></h3><h3><span id="消息传递通信机制p157">消息传递通信机制（p157）</span></h3><ul>
<li><p>进程通信是指协作进程间的信息交换。</p>
</li>
<li><p>分类</p>
<ul>
<li><p>低级进程通信：效率低，主要针对信息的传送。</p>
<p>典型实例为信号量机制。semaphore</p>
</li>
<li><p>高级进程通信：能以高速率传输大量数据；进程通信实现细节由操作系统提供，整个通信过程对用户透明，通信程序编制简单。</p>
<ul>
<li><p><strong>管道</strong>通信机制 pipe</p>
<p>管道是单向的。</p>
<p>管道通信借助于<strong>文件系统</strong>的机制实现。</p>
</li>
<li><p><strong>共享内存</strong>通信机制 shared memory</p>
<p>互相通信的协作进程建议一块<strong>共享内存区域</strong>，进程通过向此共享区域读出或写入数据来交换信息。</p>
</li>
<li><p><strong>消息传递</strong>通信机制 message passing</p>
<p>数据交换以<strong>消息</strong>message为<strong>单位</strong>，程序运直接利用系统提供的一组<strong>通信原语</strong>来实现通信。</p>
<ul>
<li><p>直接(同步)通信</p>
</li>
<li><p>间接(异步)通信</p>
<p>借助于收发双方进程之外的共享数据结构作为通信中转，该共享的内存称为<strong>信箱</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="3-死锁">3 死锁</span></h2><h3><span id="死锁概述p161要点20">死锁概述（p161）(要点20)</span></h3><ul>
<li><p><strong>死锁的定义</strong>：多个进程因竞争系统资源或互相通信而处于<strong>永久等待状态</strong>，若无外力作用，这些进程都将无法向前推进。</p>
</li>
<li><p>死锁的成因</p>
<ul>
<li>系统资源不足</li>
<li>进程推进次序不当</li>
</ul>
<p>死锁与进程的推进速度、资源的数量、资源的分配策略有关。</p>
</li>
<li><p><strong>死锁产生的必要条件</strong></p>
<ul>
<li><p>互斥条件</p>
<p>一个时刻，一个资源仅能被一个进程占有。</p>
</li>
<li><p>不可剥夺条件</p>
<p>除了资源占有进程主动释放资源，其他进程都不可抢夺其资源。</p>
</li>
<li><p>占有和等待条件</p>
<p><strong>请求</strong>资源未果进程虽阻塞但<strong>保持</strong>占有资源不放。</p>
</li>
<li><p>循环等待条件(前三个条件同时存在产生的结果)</p>
<p>存在一个进程等待队列{P1,P2,…,Pn}，其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。</p>
</li>
</ul>
<p>四个条件同时成立时，死锁才有可能发生；</p>
<p>如果这四个条件不同时成立，则必然不会引发死锁！</p>
</li>
<li><p>死锁和饥饿</p>
<ul>
<li><p>死锁 循环等待资源</p>
<p>死锁的进程数必须大于或等于两个；</p>
<p>处于死锁的进程必定是等待态。</p>
</li>
<li><p>饥饿 进程长时间的等待</p>
<p>e.g. 低优先级进程欧洲那个是等待高优先级进程所占有的资源</p>
<p>进入饥饿的进程可能只有一个；</p>
<p>处于饥饿的进程可以是一个就绪进程。</p>
</li>
<li><p>对比 死锁→饥饿(反之不亦然)</p>
<p>饥饿可能自行解除；</p>
<p>如无外部干涉，死锁无法终止。</p>
</li>
</ul>
</li>
<li><p>死锁的解决方案</p>
<ul>
<li><p>死锁的预防——静态方法</p>
<p>破环四个必要条件之一。</p>
</li>
<li><p>死锁的避免——动态方法</p>
<p>允许四个必要条件同时存在，看是否能找到一个资源分配的安全序列，进而决定是否分配。<strong>银行家算法</strong></p>
</li>
<li><p>死锁的检测和恢复</p>
<p>允许死锁发生，系统及时地检测死锁并解除它。</p>
</li>
</ul>
</li>
</ul>
<h3><span id="死锁的预防p162要点21">死锁的预防（p162）(要点21)</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2.png" class>

<h3><span id="死锁的避免p163要点22">死锁的避免（p163）(要点22)</span></h3><p>基本思路：系统对进程每次发出的资源申请，进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配。</p>
<p>一个典型的动态检查算法：银行家算法</p>
<h3><span id="银行家算法p165~168考点413">银行家算法（p165~168）(考点4/13)</span></h3><ul>
<li><p>安全状态和安全序列</p>
<p>如果系统能按照某种顺序，如&lt;P1,P2,…,Pn&gt;来为每个进程分配资源，直至最大需求，使每个进程都可以顺利允许完成，则称此时的系统状态为安全状态，称&lt;P1,P2,…,Pn&gt;为安全序列。</p>
<p>若某一时刻系统中不存在一个安全序列，则称此时的系统状态为不安全状态。</p>
<p>当系统进入不安全状态后，便可能陷入死锁，但并非所有的不安全状态都是死锁状态。</p>
<p>只要保证系统处于安全状态，便可避免死锁。</p>
</li>
<li><p>银行家算法数据结构</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class></li>
<li><p>银行家算法步骤依次是：</p>
<ul>
<li><p>主体算法</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E4%B8%BB%E4%BD%93%E7%AE%97%E6%B3%95.png" class></li>
<li><p>安全性算法</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%97%E6%B3%95.png" class></li>
</ul>
</li>
</ul>
<h3><span id="死锁的检测和恢复p168~170">死锁的检测和恢复（p168~170）</span></h3><ul>
<li><p>死锁的检测</p>
<p>死锁定理</p>
</li>
<li><p>死锁的恢复</p>
<p>最经典的还得是重启</p>
</li>
</ul>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%89%93%E5%8D%B0%E6%9C%BA.png" class>

<p>解析：当每个进程都获得了2台打印机且系统中剩余打印机不少于1台时，系统不会发生死锁，即11-2*N&gt;=1，由此可知N&gt;=5。</p>
<h1><span id="第四章-存储管理">第四章 存储管理</span></h1><h2><span id="1-存储器管理概述">1 存储器管理概述</span></h2><h3><span id="存储器层次结构p194">存储器层次结构（p194）</span></h3><ul>
<li>寄存器 0.25~0.5ns</li>
<li>高速缓存 0.5ns~25ns</li>
<li>内存 80~250ns</li>
<li>磁盘 ms</li>
<li>磁带</li>
</ul>
<h3><span id="程序的处理过程p195~198要点23">程序的处理过程（p195~198）(要点23)</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" class>

<ul>
<li>程序编译</li>
<li>程序链接</li>
<li>程序装载</li>
</ul>
<h3><span id="地址重定位">地址重定位</span></h3><p><strong>逻辑地址转化为物理地址</strong>的过程称为地址映射或称<strong>地址重定位</strong>或称地址转换。</p>
<ul>
<li><p>静态地址重定位</p>
<p>由装载程序在将可执行代码装入内存时一次性完成重定位，将其中所有逻辑地址修改成物理地址。</p>
</li>
<li><p>动态重定位</p>
<p>装载程序对逻辑地址不做任何修改，在程序执行过程中由硬件装置MMU将指令中的逻辑地址动态转换成物理地址。</p>
</li>
</ul>
<h3><span id="内存分配方式ppt-p9">内存分配方式（PPT p9）</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png" class>

<ul>
<li><p>连续分配方式</p>
<ul>
<li>固定分区</li>
<li>可变/动态分区</li>
</ul>
</li>
<li><p>离散分配方式</p>
<ul>
<li>基本分段/请求分段</li>
<li>基本分页/请求分页</li>
<li>基本段页式/请求段页式</li>
</ul>
<p>请求分段、请求分页用到了虚拟内存技术。</p>
</li>
</ul>
<h2><span id="2-连续存储管理">2 连续存储管理</span></h2><ul>
<li><strong>外部碎片</strong>指的是还没有被分配出去(不属于任何进程)，但由于太小了，无法分配给申请内存空间的新进程的内存空闲区域。</li>
<li><strong>内部碎片</strong>指的是处于去内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而进程占有这个存储块时，系统无法利用它，直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</li>
</ul>
<h3><span id="固定分区存储管理p199要点24">固定分区存储管理（p199）(要点24)</span></h3><p>系统实现把内存用户区划分为若干固定大小的分区，进程装入大与等于自身大小的空闲分区中。</p>
<ul>
<li><p>优点</p>
<p>可用于多道程序系统最简单的存储分配。</p>
</li>
<li><p>缺点</p>
<ul>
<li>导致分区内的内部碎片出现，内存利用率不高；→从而发展出可变分区</li>
<li>由于预先依规定分区大小，使得大作业无法装入；→覆盖技术</li>
<li>分区数目在系统初启时确定，从而限制多道允许程序的道数；→交换技术</li>
</ul>
</li>
</ul>
<h3><span id="可变分区存储管理p200">可变分区存储管理（p200）</span></h3><p>根据进程的实际需求，动态地对内存空间进行分配、回收及划分，使分区的大小刚好和进程的大小相等。</p>
<ul>
<li><p>外部碎片问题</p>
<p>在可变分区存储管理方式中，经过一段时间的分配回收后，内存中存在很多、很小的空闲块。它们每一个都很小，不足以满足分配要求，这些空闲块被称为外部碎片，造成存储资源的浪费。</p>
</li>
<li><p>移动技术</p>
<p>通过在内存移动程序，将所有小的空闲区域合并为大的空闲区域。</p>
</li>
</ul>
<h3><span id="地址转换和内存保护p202">地址转换和内存保护（p202）</span></h3><h3><span id="移动覆盖交换技术p204要点25">移动/覆盖/交换技术（p204）(要点25)</span></h3><h2><span id="3-分页存储管理">3 分页存储管理</span></h2><h3><span id="基本原理p206-ppt-p5761考点513">基本原理（p206 PPT p57/61）(考点5/13)</span></h3><ul>
<li><p>页框/页帧(frame)</p>
<p>把<strong>物理内存空间</strong>划分成固定大小的块，称为页框或页帧。页框从0开始连续编号，称为页框号或页帧号。</p>
</li>
<li><p>页面(page)</p>
<p>程序逻辑地址空间按页框大小分为若干页面，不足一页的部分补齐为一页，依序从0、1…..编号，称为页号。</p>
</li>
<li><p>页表(page table)</p>
<p>是在<strong>进程装入内存时</strong>，由<strong>系统为进程建立</strong>的<strong>页面和页框的映射表</strong>，其大小随进程大小而定。</p>
</li>
<li><p>页框表</p>
<p>内存也狂飙整个系统一张，指出物理内存页框的分配情况(进程无关)</p>
</li>
<li><p>页面大小和逻辑地址切分</p>
<p>分页存储，逻辑地址由页号和页内位移组成</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%87%E5%88%86.png" class></li>
</ul>
<h3><span id="具有快表的地址转换p208考点613">具有快表的地址转换（p208）(考点6/13)</span></h3><ul>
<li><p>翻译快表TLB</p>
<p>是一组<strong>存放最近访问的部分页表项的cache</strong>。</p>
<p>TLB的一个表项由页号page number和页框号frame number组成。</p>
</li>
<li><p>地址转换过程</p>
<ul>
<li>MMU读出CPU给出的有效逻辑地址，自动分成页号和页内地址，将页号<strong>与快表中</strong>的页号比较。</li>
<li>若其中<strong>有相匹配的页号</strong>，表示快表存在所要访问的页表项，直接读出对应的页框号，形成物理地址。</li>
<li>若快表中<strong>未找到对应的页表项</strong>，则MMU访问内存中的页表，形成物理地址，形成物理地址，并将该条页表项记入TLB。</li>
<li>若快表已满，则系统根据某种算法找到一个不再需要的页表项换出。</li>
</ul>
</li>
<li><p>快表的引入可以减少地址转换时间，提高数据存取速度。</p>
</li>
</ul>
<h3><span id="页的共享与保护p209">页的共享与保护（p209）</span></h3><ul>
<li><p>页的共享</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E9%A1%B5%E7%9A%84%E5%85%B1%E4%BA%AB.png" class></li>
<li><p>页的保护</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E9%A1%B5%E7%9A%84%E4%BF%9D%E6%8A%A4.png" class></li>
</ul>
<h3><span id="多级页表和反置页表p211要点26">多级页表和反置页表（p211）(要点26)</span></h3><ul>
<li><p>多级页表</p>
<p>多级页表，即对页表分页(<strong>页表页</strong>)，页表页离散地存储在物理内内存中。</p>
<ul>
<li><p>应对的问题：</p>
<p>单级页表要求页表连续存放，而现代计算机系统逻辑地址空间很大，没有那么大的连续地址空间来分配给页表，为了解决这个问题，提出多级页表。</p>
</li>
<li><p>两级页表</p>
<p>对页表进行分页(<strong>页表页</strong>)，对它们进行编号并离散地存放在不同的页框中；同时为离散存储的页表页再建立一张页表，称之为<strong>页目录表</strong>,，以记录各页表页对应的页框号</p>
<p>页目录表的每个表项指出页表页存储的页框号；</p>
<p>页表的每个表项指出页面和页框的对应关系。</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8.png" class>

<p>二级页表地址转换需要三次访存，一次访问页目录、一次访问页表页、一次访问指令或数据。</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" class></li>
</ul>
</li>
<li><p>反置页表</p>
<p>整个系统设置一张反置页表，每一个物理页框对应一个条目，每个页表条目记录页号及其隶属进程的pid，按页框号排序。</p>
<p>逻辑地址三元组：&lt;pid,页号,页内偏移&gt;</p>
<ul>
<li><p>应对的问题</p>
<p>解决的是现代计算机系统逻辑地址空间庞大，进程页表可能非常庞大的问题。</p>
</li>
</ul>
</li>
</ul>
<h2><span id="4-分段存储管理">4 分段存储管理</span></h2><h3><span id="基本原理p214要点27">基本原理（p214）(要点27)</span></h3><ul>
<li>分段及段表<ul>
<li>进程的逻辑地址空间由若干大小不等的程序段构成，每个段都有段名和段长。段的长度和用途有关。</li>
<li>进程以段为单位在物理内存中离散地存储。</li>
<li>通过段表对进程的地址进行映射。<ul>
<li>段表由段号、段基址和段长度组成。</li>
</ul>
</li>
</ul>
</li>
<li>逻辑地址结构：&lt;段号，段内位移&gt;</li>
</ul>
<h3><span id="地址转换和内存保护p214要点28">地址转换和内存保护（p214）(要点28)</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%B6%8A%E7%95%8C%E4%BF%9D%E6%8A%A4.png" class>

<h3><span id="段的共享和保护p215">段的共享和保护（p215）</span></h3><h3><span id="分段和分页比较p215要点29">分段和分页比较（p215）(要点29)</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%88%86%E9%A1%B5VS%E5%88%86%E6%AE%B5.png" class>

<ul>
<li>分段是信息的逻辑单位，由源程序的逻辑结构及含义所决定，是用户可见的，段长由用户根据需要来确定，段起始地址可从任何内存地址开始。在分段方式中，源程序(段号、段内位移)经链接装配后保持二维(地址)结构，引入目的是满足用户模块化程序设计的需要。</li>
<li>分页是信息的物理单位，与原程序的逻辑结构无关，是用户不可见的，页长由系统(硬件)确定，页面只能从页大小的整数倍地址开始。在分页方式中，源程序(页号、页内位移)经链接装配后编程一维(地址)结构，引入目的是实现离散分配并提高内存利用率。</li>
</ul>
<h2><span id="5虚拟存储管理-考点713">5虚拟存储管理 (考点7/13)</span></h2><h3><span id="概念和关键技术p215">概念和关键技术（p215）</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A81.png" class>

<p>部分交换和部分覆盖</p>
<h3><span id="请求分页及硬件支持p217">请求分页及硬件支持（p217）</span></h3><ul>
<li><p>何为请求分页？</p>
<p>在进程的执行过程中，页面仅在需要时被载入内存；那些从未被访问的页面将永远不会调入内存。</p>
</li>
<li><p>硬件支持</p>
<ul>
<li><p>页表项的扩充(除了原有页号和页框号外，还扩充了状态位，外存地址和其他标志位)</p>
<ul>
<li><p>状态位：指示对应页面是否已装入主存。</p>
</li>
<li><p>外存地址：记录页面在外存中的位置。</p>
</li>
<li><p>其他标志位：</p>
<p>修改位(M)：当一个页面被修改后会置该位，意味着该页被调出内存时必须回写到外存上。该位也称为脏数据位。</p>
<p>引用位(R)：该页被引用时设置，用于页面置换算法。</p>
<p>访问权限位(A)：限定了该页的访问权限(R,R/W)。</p>
</li>
</ul>
</li>
<li><p>MMU功能的扩充：</p>
<ul>
<li><p>MMU时完成逻辑地址到物理地址转换功能的低层硬件设施</p>
</li>
<li><p>扩充的功能：</p>
<p>管理标志位</p>
<p>如页面不在内存当中或出现越界现象时，MMU发出<strong>缺页中断</strong>或越界中断。</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/MMU%E5%8A%9F%E8%83%BD%E6%89%A9%E5%85%85.png" class></li>
</ul>
</li>
<li><p>缺页中断机构</p>
<ul>
<li><p>缺页中断的特殊性</p>
<p>在指令执行期间产生和处理中断信号；</p>
<p>一条指令执行期间，可能产生多次缺页中断。</p>
</li>
<li><p>缺页中断的处理过程</p>
<p>1）保护CPU现场</p>
<p>2）分析缺页原因</p>
<p>3）转入缺页中断处理程序</p>
<p>4）恢复CPU现场</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B.png" class></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>请求分页的软件的软件策略：</p>
<ul>
<li>页面装入策略：决定某页何时装入内存。</li>
<li>页面清楚策略：确定何时将已修改的一页写回外存</li>
<li>页面分配策略：为某个活动进程分配多少页框？页框数是否可变?置换时，是从发生缺页的进程中置换页面，还是可以患处内存中其他进程的页面。</li>
<li><strong>页面置换策略：在计划置换的页集中，选择换出哪一页？</strong></li>
</ul>
<h3><span id="页面装入策略p221">页面装入策略（p221）</span></h3><h3><span id="页面清除策略p221">页面清除策略（p221）</span></h3><h3><span id="页面分配策略p222">页面分配策略（p222）</span></h3><h3><span id="缺页中断率p223要点30">缺页中断率（p223）(要点30)</span></h3><ul>
<li>缺页率=缺页次数/页面访问次数</li>
<li>影响缺页中断率的因素<ul>
<li>内存<strong>页框数</strong>：进程所分得的块数多，缺页中断率低，反之缺页中断率就高。</li>
<li><strong>页面大小</strong>：页面大，缺页中断率低，否则缺页中断率就高。</li>
<li><strong>页面替换算法</strong>：算法的优劣影响缺页异常次数。</li>
<li><strong>程序特性</strong>：程序局部性要好，它对缺页中断率有很大影响。</li>
</ul>
</li>
</ul>
<h3><span id="页面置换算法又称页面淘汰算法p224~227考点813">页面置换算法——又称页面淘汰算法（p224~227）(考点8/13)</span></h3><ul>
<li><p>最佳页面置换算法OPT</p>
<p>从页面访问序列中选择永不使用或是在最长时间内不再被访问(即句现在最长时间才会被访问)的页面淘汰出内存。</p>
</li>
<li><p>先进先出置换算法FIFO</p>
<p>在当前页框中选择驻留时间最久的页面淘汰出内存，</p>
<p>进程已调入内存的页面按先后次序连接成一个队列，并设置替换指针以指向最老页面。</p>
</li>
<li><p>最近最久未使用置换算法LRU</p>
<p>根据局部性原理，在当前页框中选择最近一段时间最长时间未被访问的页面淘汰出内存。</p>
<p>使用一个特殊队列实现，队列存放当前内存中的页号，队列头指向最久未访问的页，队列尾指向最近访问的页，每执行一次页面访问就做一次队列调整：如果页面在内存中，则将该页调整至队列尾；如果发生缺页，则淘汰队列头指向的那一页。</p>
</li>
</ul>
<h3><span id="抖动问题及解决方案ppt-p127">抖动问题及解决方案（PPT p127）</span></h3><ul>
<li>抖动：刚被淘汰的页面立即又要调用，而调入不久随即被淘汰，淘汰不久再被调入，如此反复，使得整个系统的页面调度非常频繁，以致大部分时间都花在来回调度页面上，而不是执行计算任务，这种现象叫做”抖动”或”颠簸”。</li>
<li>成因：<ul>
<li>并发进程数量过多</li>
<li>进程页框分配不合理</li>
</ul>
</li>
<li>解决方案：<ul>
<li>基于工作集策略的解决方案</li>
<li>基于缺页中断率的解决方案：测量和控制缺页中断率，动态调节分配给进程的页框数，以防止抖动</li>
<li>终极解决方案：增加物理内存</li>
</ul>
</li>
</ul>
<h1><span id="第五章-设备管理">第五章 设备管理</span></h1><h2><span id="1-io硬件原理">1 I/O硬件原理</span></h2><h3><span id="io硬件组成p255">I/O硬件组成（p255）</span></h3><ul>
<li><p>设备分类</p>
<ul>
<li>存储型设备 磁盘<ul>
<li>磁盘、磁带等。</li>
<li>大容量存储和快速检索为目标。</li>
</ul>
</li>
<li>I/O型设备 终端<ul>
<li>显示器、打印机、键盘、鼠标、通信设备等。</li>
<li>人机交互或计算机间通信。</li>
</ul>
</li>
</ul>
</li>
<li><p>设备连接计算机的基本要素</p>
<ul>
<li><p>总线</p>
<p>一组线路和一组定义在线路上传输数据的协议。</p>
</li>
<li><p>端口</p>
<p>设备与计算机的连接点。</p>
</li>
<li><p>控制器</p>
</li>
<li><p>用来操作端口、总线或设备的一组电子器件。</p>
</li>
</ul>
</li>
</ul>
<h3><span id="io控制方式p256">I/O控制方式（p256）</span></h3><p>I/O控制方式，即CPU对I/O操作的控制方式。</p>
<ul>
<li><p>轮询，又称程序I/O控制方式</p>
</li>
<li><p>中断——中断机制的引入</p>
</li>
<li><p>DMA——DMA控制器、数据传输单位扩大</p>
<p>内存与外设直接进行数据交换</p>
</li>
<li><p>通道——通道、I/O操作和数据传送的独立</p>
<p>通道又称输入输出处理器，是独立于CPU的专门实现输入输出工作的处理器；</p>
<p>通道以内存为中心，控制设备和内存之间进行数据传输，把CPU从琐碎的输入输出操作中解放出来；</p>
<p>通道一般用于具有较多高速外设的大型计算机系统。</p>
</li>
</ul>
<h2><span id="2-io软件原理">2 I/O软件原理</span></h2><h3><span id="io设计目标和原则p260">I/O设计目标和原则（p260）</span></h3><ul>
<li>设计目标：<ul>
<li><strong>高效率</strong>：核心效率问题是<strong>磁盘的I/O效率</strong>。</li>
<li><strong>通用性</strong>：<strong>采用层次化的方法设计I/O软件系统，屏蔽低层硬件细节</strong>。</li>
</ul>
</li>
</ul>
<p>I/O软件系统的层次：</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/IO%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1.png" class>

<h3><span id="io中断处理程序p260">I/O中断处理程序（p260）</span></h3><ul>
<li>I/O中断处理程序是设备驱动程序的组成部分，位于操作系统低层</li>
<li>功能：处理I/O中断，报告错误，唤醒驱动程序等</li>
</ul>
<h3><span id="io设备驱动程序p261">I/O设备驱动程序（p261）</span></h3><ul>
<li><p>该层包含与设备密切相关的代码，每种设备类型都应该有对应的设备驱动程序；</p>
<p>设备驱动负责I/O设备的初始化，执行I/O设备的驱动例程，执行中断处理例程。</p>
</li>
</ul>
<h3><span id="独立于设备的io软件p262">独立于设备的I/O软件（p262）</span></h3><ul>
<li><p><strong>执行适用于所有设备的常用I/O功能，并向用户层软件提供一致性接口</strong></p>
</li>
<li><p>功能：</p>
<p>设备命名和设备保护</p>
<p>提供独立于设备的块大小</p>
<p>缓冲区管理——<strong>缓冲技术</strong></p>
<p><strong>设备分配</strong>和<strong>状态跟踪</strong></p>
<p>错误报告</p>
</li>
</ul>
<h3><span id="用户空间的io软件p263">用户空间的I/O软件（p263）</span></h3><ul>
<li><strong>实现与用户交互的接口</strong>，用户可以直接调用在用户层提供的与I/O操作有关的库函数，如I/O系统调用、I/O格式化、<strong>SPOOLing</strong>等</li>
<li>库函数</li>
<li>SPOOLing软件</li>
</ul>
<p>(独立于设备的I/O软件)缓冲技术、设备分配  和  (用户空间的I/O软件)SPOOLing技术：</p>
<ul>
<li><p>缓冲技术</p>
<ul>
<li>缓冲区是系统在<strong>内存中</strong>开辟的一个专门区域，用于临时存放I/O操作的数据</li>
<li>缓冲区的主要用途是处理生产者设备和消费者设备之间<strong>数据流速度不匹配</strong>的问题</li>
</ul>
</li>
<li><p>设备分配及调度</p>
<p>设备分配方式——依赖于设备的物理特性</p>
<ul>
<li><p>独占分配方式——大多数低俗设备都适合采用这种分配方式</p>
<p>将一个设备分配给某个进程后便已知由该进程独占，直至该进程完成或释放该设备，系统才能将该设备分配给其他进程使用。</p>
</li>
<li><p>共享分配方式</p>
<p>对于高速共享设备(如磁盘)一般不进行分配，主要工作是驱动调度</p>
</li>
<li><p>虚拟分配方式——如SPOOling技术</p>
<p>在分配时并不是真实的物理设备，而只是在高速磁盘中为进程分配的存储区，实现对慢速独占设备的模拟分配和共享。</p>
</li>
</ul>
</li>
<li><p>SPOOLing技术，即假的脱机技术。</p>
<p>操作系统中采用的一项将独占设备改造成共享设备的技术。</p>
<p>借助于高速随机外存(<strong>磁盘</strong>)的支持。</p>
</li>
</ul>
<ul>
<li>I/O请求生命周期</li>
</ul>
<p>课本P264 图5-1</p>
<h2><span id="3-磁盘管理">3 磁盘管理</span></h2><p>磁盘是可共享设备，但每一时刻至多只能有一个进程启动它。</p>
<h3><span id="磁盘参数">磁盘参数</span></h3><ul>
<li><p>磁盘块定位三要素</p>
<ul>
<li><p>柱面号</p>
<p>指盘面上的磁道号，磁道号由外向里，不同盘面上具有相同编号的磁道属于同一柱面；</p>
</li>
<li><p>磁头号</p>
<p>指出读写磁头所在的盘面，磁头号从上到下的盘面次序从0开始编号；</p>
</li>
<li><p>扇区号</p>
<p>按磁盘旋转方向从0开始给各扇区编号</p>
</li>
</ul>
</li>
<li><p>磁盘恒定角速度和恒定线速度</p>
<ul>
<li><p>恒定角速度</p>
<p>所有磁道的扇区数相等，内部磁道到外部磁道的比特密度不断降低</p>
<p>磁盘转速恒定</p>
<p>用于磁盘</p>
</li>
<li><p>恒定线速度</p>
<p>每个磁道的比特密度均匀</p>
<p>外磁道扇区比内磁道多，可存放更多的数据</p>
<p>为保持传输数据率的恒定，随着柱面的改变转速要不断变化</p>
<p>用于CD-ROM和DVD-ROM驱动器</p>
</li>
</ul>
</li>
</ul>
<h3><span id="磁盘格式化">磁盘格式化</span></h3><ul>
<li><p>低级格式化</p>
<ul>
<li>又称<strong>物理格式化</strong></li>
<li>将盘片划出磁道、扇区</li>
<li>为每个扇区使用特殊的数据结构进行填充，包括一个头部、数据区域和一个尾部</li>
</ul>
</li>
<li><p>高级格式化</p>
<ul>
<li>又称<strong>逻辑格式化</strong></li>
<li>划分由相邻柱面组成的多个分区</li>
<li>为分区构建文件系统，在磁盘上初始化文件系统数据结构，如空闲、已分配分区表、一个空目录。</li>
</ul>
</li>
</ul>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%A0%BC%E5%BC%8F%E5%8C%96.png" class>

<ul>
<li><p>磁盘的性能指标</p>
<p>查找一个物理块的顺序是：柱面号、磁头号、扇区号，其中柱面号和磁头号都是为了确定磁道。</p>
<ul>
<li><p>寻道时间$T_s$</p>
<p>将磁头定位到正确磁道(柱面)上所花的时间，与盘片直径和传动臂速度相关，一般会直接给出。</p>
</li>
<li><p>旋转延迟$T_r$</p>
<p>指定扇区旋转到磁头下面所经历的平均延迟时间：$T_r=1/2*r$，r为磁盘的旋转速度。</p>
</li>
<li><p>传输时间$T_t$</p>
<p>传输扇区内数据的时间，同样取决于磁盘的旋转速度。</p>
<p>$T_t=b/(r*N)$，b为要传送的字节数，N为一个磁道中的字节数，r为转速，N×r是磁盘的数据传输速率。</p>
</li>
<li><p>磁盘完成一次I/O的平均访问时间=寻道时间+旋转延迟+传输时间</p>
</li>
</ul>
</li>
</ul>
<h3><span id="移动臂调度算法p270~274考点1013">移动臂调度算法（p270~274）(考点10/13)</span></h3><p>又叫磁盘调度技术。</p>
<ul>
<li>看大题考点部分<ul>
<li>先来先去</li>
<li>最短寻道时间优先</li>
<li>扫描</li>
<li>循环扫描</li>
<li>电梯</li>
</ul>
</li>
</ul>
<h3><span id="独立磁盘冗余阵列ppt-p82">独立磁盘冗余阵列（PPT p82）</span></h3><p>直到RAID0是无冗余的磁盘阵列，无冗余就是没校验位，无容错能力，系统可靠性差，但架不住速度快。</p>
<h1><span id="第六章-文件管理">第六章 文件管理</span></h1><h2><span id="1-文件">1 文件</span></h2><h3><span id="基本概念p297">基本概念（p297）</span></h3><ul>
<li><p>怎么看文件？</p>
<ul>
<li><p>用户观点——文件逻辑结构</p>
<p>文件是一些具有结构的信息集合，如一篇文章分成很多段落、一个程序分成很多函数。</p>
</li>
<li><p>系统观点——文件物理结构</p>
<p><strong>文件就是一组存放在扇区里的数据，不关心它的内容和格式。</strong></p>
</li>
</ul>
</li>
<li><p>文件系统是指文件、管理文件的软件及数据结构的总体。</p>
</li>
<li><p>文件系统的功能</p>
<p>主要目的是实现<strong>对文件的”按名存取”</strong>:</p>
<ul>
<li>文件的命名</li>
<li>实现文件从逻辑结构和物理结构映射</li>
<li>统一管理文件存储空间，实施存储空间的分配与回收</li>
<li>实现文件信息的共享，并提供文件保护和保密机制</li>
<li>向用户提供一个方便使用的接口</li>
</ul>
</li>
</ul>
<h3><span id="文件类型和属性p299">文件类型和属性（p299）</span></h3><ul>
<li><p>文件的类型</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B.png" class></li>
<li><p>文件的属性</p>
<ul>
<li>文件名——<strong>按名存取</strong></li>
<li>类型</li>
<li>大小</li>
<li>位置</li>
<li>创建时间、修改时间</li>
<li>文件所有者ID</li>
<li>存取权限</li>
</ul>
</li>
</ul>
<h3><span id="文件的逻辑结构p305">文件的逻辑结构（p305）</span></h3><img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" class>

<ul>
<li><p>流式文件</p>
<p>文件中的信息仅仅是一串顺序的字符集合，没有明显的结构。操作系统所见到的只是字节流，其文件内容的任何含义<strong>在用户程序中解释</strong>。</p>
</li>
<li><p>记录式文件</p>
<p>文件的信息单位是逻辑记录，一个逻辑记录包含了若个数据项，记录分为：<strong>定长</strong>记录和<strong>变长</strong>记录</p>
<ul>
<li><p>记录的成组与分解</p>
<p>磁盘空间分配、内存和磁盘之间的I/O传输以块(簇)为单位的，逻辑记录的大小和物理块不相等。</p>
<ul>
<li>成组：将若干逻辑记录打包成组后再装入物理块的过程。</li>
<li>分解：把一个物理块里的逻辑记录分离出来的过程。</li>
</ul>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%96%87%E4%BB%B6%E8%AE%B0%E5%BD%95%E7%9A%84%E6%88%90%E7%BB%84%E4%B8%8E%E5%88%86%E8%A7%A3.png" class></li>
</ul>
</li>
</ul>
<h3><span id="文件的物理结构p308-见最后第二点">文件的物理结构（p308） 见最后第二点</span></h3><h3><span id="文件的存取方法p300或叫文件的访问方法">文件的存取方法（p300）或叫文件的访问方法</span></h3><ul>
<li><p>顺序存取(访问)——磁带模型</p>
</li>
<li><p>直接存取——磁盘模型</p>
<p>若文件的<strong>逻辑记录长度固定</strong>，那么允许在访问文件信息时可按任意顺序进行快速读取和写入。</p>
</li>
<li><p>索引存取</p>
<p>基于索引文件的存取方法；</p>
<p>文件记录按键值排序。</p>
</li>
</ul>
<h3><span id="文件的访问控制">文件的访问控制</span></h3><p>文件的访问控制一般有：读r、写w、执行x——4、2、1</p>
<p>owner、group、others</p>
<h2><span id="2-文件目录">2 文件目录</span></h2><h3><span id="概述">概述</span></h3><ul>
<li><p>分区：将一个磁盘分若干分区，安装了文件系统的分区称为卷，每个磁盘至少一个卷</p>
</li>
<li><p>目录：存储一个分区中的文件信息</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%88%86%E5%8C%BA%E5%92%8C%E7%9B%AE%E5%BD%95.png" class></li>
<li><p>目录管理的功能</p>
<ul>
<li>允许文件重名</li>
<li>按名存取</li>
<li>提高检索速度</li>
<li>文件共享</li>
</ul>
</li>
<li><p>文件目录实现的关键</p>
<ul>
<li>目录项与文件物理地址的关联方法：<ul>
<li>目录项的构成</li>
<li>文件的物理结构</li>
</ul>
</li>
<li>在目录中”按名”搜索的效率：<ul>
<li>目录的结构</li>
<li>目录检索和实现</li>
</ul>
</li>
</ul>
</li>
<li><p>目录文件</p>
<ul>
<li>文件目录也用文件形式保存在磁盘上，被称为目录文件，包含该目录的所有文件和子目录的目录项；</li>
<li>目录文件具有固定格式，由系统生成并管理，用户不能直接访问目录；</li>
<li>目录文件不能为空，至少包括两个目录项，即当前目录项”.”和父目录项”..”。</li>
</ul>
</li>
<li><p>目录项</p>
<p><strong>俩个体系</strong>下的目录项</p>
<ul>
<li>文件控制块(FCB)</li>
<li>文件名&amp;索引节点(inode)编号</li>
</ul>
</li>
</ul>
<h3><span id="fcb和inode">FCB和inode</span></h3><ul>
<li><p>文件控制块FCB</p>
<p>每一条目录项中有一个FCB。</p>
<ul>
<li>操作系统为每个文件建立的包含文件全部属性信息的唯一数据结构，其目的时为方便操作系统对文件的管理控制和存取。</li>
<li>文件被创建时，系统为其建立一个FCB，用来记录文件的信息</li>
<li>在该体系下，文件=FCB+文件体；</li>
<li>每当存取文件时，先找其FB，将其读入内存，再从中找到文件首块物理位置或索引表，随后存取文件信息。</li>
</ul>
</li>
<li><p>引入索引节点inode</p>
<ul>
<li><p>目录项由文件名和inode号组成。</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9.png" class>

<ul>
<li>文件=目录项+inode+文件体</li>
</ul>
</li>
<li><p>Linux的inode包含信息</p>
<ul>
<li>文件类型</li>
<li>文件的ACL</li>
<li>文件的硬连接数量</li>
<li>文件主的用户ID</li>
<li>文件的所属组ID</li>
<li>文件字节数</li>
<li>文件最后访问的日期和时间atime</li>
<li>文件最后修改的日期和时间mtime</li>
<li>文件状态最后修改的日期和时间ctime</li>
<li><strong>含15个盘块地址的数组</strong></li>
</ul>
</li>
<li><p>Linux读取硬盘的基本单位是块(block)，连续八个扇区(sector)组成一个bolck，一个block大小为4KB</p>
</li>
</ul>
</li>
<li><p>目录结构</p>
<ul>
<li><p>单级目录结构</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class></li>
<li><p>两级</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class></li>
<li><p>树形</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" class></li>
</ul>
</li>
<li><p>文件目录的检索</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E7%B4%A2.png" class>

<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E7%B4%A22.png" class></li>
<li><p>文件目录的实现</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0.png" class></li>
<li><p>文件的共享</p>
<p>文件共享是指多个用户共同使用同一个文件。在Linux中，可通过链接实现文件共享。</p>
<p>看大题部分</p>
<ul>
<li><p>硬链接——基于索引节点的链接 ln myfile.txt my-hard-link</p>
<p>实现原理：</p>
<ul>
<li><strong>多个文件名</strong>链接到<strong>同一个索引节点</strong>。</li>
<li>索引节点的引用计数记录在索引结点的链接计数中，若其减至0，则文件被删除</li>
</ul>
<p>优点：</p>
<ul>
<li>实现简单，访问速度快，能实现文件的异名共享。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>只</strong>允许在<strong>同一个文件系统</strong>范围内进行，不允许跨文件系统；</li>
<li><strong>文件拥有者不能删除被他人共享的文件</strong>。</li>
</ul>
</li>
<li><p>软连接——基于符号的链接 ln -s myfile.txt my-soft-link</p>
<p>实现原理：</p>
<ul>
<li>特殊类型的文件，其<strong>内容是另一个目录或文件路径的链接</strong></li>
<li>建立符号链接文件，并不影响原文件——它们是独立的文件</li>
</ul>
<p>优点:</p>
<ul>
<li>文件所有者能删除被他人共享的文件</li>
<li>给出何时的文件路径名，即可链接网络中任何地方计算机中的文件</li>
</ul>
<p>缺点：</p>
<ul>
<li>当其他用户读共享文件时，需要根据文件路径名的各个分量逐个查找，访问开销大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="3-文件系统">3 文件系统</span></h2><h3><span id="文件系统组成ppt-p62">文件系统组成（PPT p62）</span></h3><p>文件系统的组成部分：</p>
<ul>
<li><p>逻辑文件系统</p>
<p>管理文件系统的元数据信息，如文件控制块FCB、目录结构、文件保护等</p>
</li>
<li><p>文件组织模块</p>
<p>实现<strong>文件逻辑块号向物理块号的转换</strong>以及空闲空间管理。</p>
</li>
<li><p>基本文件系统</p>
<p>以<strong>磁盘地址标识</strong>要读写的物理块，向设备驱动程序发送读写命令，读取和写入磁盘物理块。</p>
</li>
</ul>
<h3><span id="通用数据结构ppt-p64">通用数据结构（PPT p64）</span></h3><ul>
<li><p>磁盘管理结构</p>
<ul>
<li><p>引导块 boot block</p>
<p>卷的第一块，包含引导操作系统所需的信息</p>
</li>
<li><p>超级块 superblock</p>
<p>包括卷(或分区)的详细信息，分区的块的数量、块的大小、空闲块的数量和指针，空闲FCB数量和FCB指针等</p>
</li>
<li><p>目录结构</p>
<p>用于组织文件</p>
</li>
<li><p>文件控制块/inode</p>
<p>包含该文件的详细些信息</p>
</li>
</ul>
</li>
<li><p>内存管理结构</p>
<ul>
<li><p>进程打开文件表</p>
<p>进程PCB的一个数据域，记录进程所有打开文件的集合。该域每条记录指向系统打开文件表中的一个表项。</p>
</li>
<li><p>系统打开文件表</p>
<p>记录系统所有打开文件的当前位置、引用计数、指向活动inode表对应表项的指针</p>
</li>
<li><p>活动inode表</p>
<p>存放最近打开文件的inode</p>
</li>
</ul>
<p>系统打开文件表和活动inode表是所有进程共享的。</p>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84.png" class></li>
</ul>
<h3><span id="文件的物理结构">文件的物理结构</span></h3><ul>
<li><p>顺序文件——连续分配</p>
<ul>
<li>分配原理<ul>
<li>文件中逻辑上连续的信息存储在磁盘上也保持连续的结构</li>
<li><strong>文件目录</strong>记录<strong>文件第一块的块号和块数</strong></li>
<li>逻辑结构和物理结构相同</li>
</ul>
</li>
<li>优点<ul>
<li>简单，只需要记录文件的起始块号和长度</li>
<li>寻道时间最少</li>
<li>支持直接存取</li>
</ul>
</li>
<li>缺点<ul>
<li>存在外部碎片</li>
<li>必须实现直到文件的长度，且不适合文件的增长</li>
</ul>
</li>
</ul>
</li>
<li><p>链接文件——链接分配，属于离散分配</p>
<ul>
<li><p>分配原理</p>
<ul>
<li>通过盘块上的指针实现同一文件多个离散物理盘块的链接；</li>
<li><strong>文件目录</strong>记录了<strong>文件第一块和最后以块的块号</strong>；</li>
<li>各块之间通过指针连接。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>消除了外部碎片，外存利用率高</li>
<li>按需分配，无需事先知道文件长度</li>
<li>支持文件动态增长，方便文件增删改查</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>指针占用盘块额外空间</li>
<li>只适合顺序访问，对随机存取及其低效</li>
<li>存在断链可能，可靠性差</li>
</ul>
<p>为了提高检索速度和减少指针占用的存储空间，可将几个盘块组成一个簇，以簇为单位进行盘块分配。这种方法会产生内部碎片，对小文件特别明显。</p>
</li>
</ul>
</li>
<li><p>索引文件</p>
<ul>
<li>分配原理<ul>
<li>将文件占用的所有物理块号按逻辑顺序保存在一张索引表中，存有索引表的物理块称为索引块</li>
<li>目录项指出索引块块号</li>
</ul>
</li>
<li>优点<ul>
<li>随机访问</li>
</ul>
</li>
<li>缺点<ul>
<li>索引块占用磁盘空间</li>
</ul>
</li>
<li><strong>多级索引大题！！！</strong></li>
</ul>
</li>
</ul>
<img src="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E6%80%BB%E6%B1%87/%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E5%B0%8F%E6%80%BB%E7%BB%93.png" class>

<h3><span id="空闲空间管理ppt-p88">空闲空间管理（PPT p88）</span></h3><ul>
<li><strong>位示图</strong>(大题)<ul>
<li>原理：每一个磁盘块用一个位来标识，如果磁盘块空闲，位位0；如果已分配，位为1。</li>
<li>优点是非常高效</li>
<li>具体实现看大体部分</li>
</ul>
</li>
<li>空闲盘块链表</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/note/" rel="tag"> <i class="fa fa-tag"></i>  note</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/27/2021%E6%AF%9B%E6%A6%82%E5%A4%8D%E4%B9%A0/" rel="prev" title="2021毛概复习">
      <i class="fa fa-chevron-left"></i> 2021毛概复习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E9%A2%98%E8%80%83%E7%82%B9/" rel="next" title="操作系统大题考点">
      操作系统大题考点 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="akaduo"
      src="/images/%E7%A2%87%E7%9C%9F%E5%97%A3.jpg">
  <p class="site-author-name" itemprop="name">akaduo</p>
  <div class="site-description" itemprop="description">克服惰性</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/akaduo2019" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;akaduo2019" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="Rss → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=1360189116&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v=3&amp;uin=1360189116&amp;site=qq&amp;menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">akaduo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">137k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:05</span>
</div>
  <!--<div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>-->
  <span class="post-meta-divider">❤</span>
  <!--<div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>-->

        








        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  <script src="https://akaduo2019.github.io/live2d/autoload.js"></script>
</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>

